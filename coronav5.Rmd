---
title: "COVID-19 effective reproduction number determination: An application, and a review of issues and influential factors"
author: 
  - "Luis Alfredo Bautista Balbás"
  - "Mario Gil Conesa"
  - "Blanca Bautista Balbás"
  - "Gil Rodríguez Caravaca"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  bookdown::word_document2:
      fig_caption: yes
      toc: true
      toc_depth: 2
      number_sections: false
      theme: journal
      reference_docx: reference.docx
  bookdown::odt_document2:
      fig_caption: yes
      toc: true
      toc_depth: 2
      number_sections: true
  bookdown::html_document2:
      fig_caption: yes
      toc: true
      toc_depth: 2
  pdf_document: 
      citation_package: natbib
  html_document: default
bibliography: bibliography.bib
biblio-style: vancouver.bst
link-citations: yes
linenumbers: yes
lot: yes
lof: yes
documentclass: article
csl: cardiff-university-vancouver.csl
---
Hospital Virgen de la Poveda, Villa del Prado, Madrid, Spain. Independent Researcher.
Hospital Fundación Alcorcón. Madrid, Spain.
Hospital Son Llatzer. Palma, Balearic Islands, Spain.
    

```{r setup, include=TRUE,warning=FALSE, message=FALSE,cache = FALSE,echo=FALSE}
userstring<-"Alfredo"   
#csl: elsevier-vancouver.csl   
#library(R0)   
#extra_dependencies: ["amsmath"]
knitr::opts_chunk$set(echo = FALSE,cache = FALSE,error=FALSE,warning=FALSE,message=FALSE)
library(knitr)
#library(mi_kableExtra) 
library(EpiEstim)
library(gridExtra)  
library(dplyr) 
library(RColorBrewer) 
library(ggpubr) ## ggarrange  
library(ggplot2) ## ggarrange 
library(tidyr)  
library(ddpcr)
#library(MLmetrics)
library(flextable) 
library(truncnorm) 
library(future)
source(paste("C:\\Users\\",userstring,"\\OneDrive\\Documentos\\myR\\libraryP.R",sep=""),encoding="UTF-8")
#source(paste("C:\\Users\\",userstring,"\\OneDrive\\Documentos\\myR\\app.R",sep=""),encoding="UTF-8")
ddpcr::quiet(Sys.setlocale("LC_ALL","English"))
mcmc_length<-1000 #1k = unrestricted
mcmc_length_oat<-1000
 
 
load("si_sample_mcmc_N_Tk.R")
load("si_sample_mcmc_X_Tk.R")
load("si_sample_mcmc_Zhao_Tk.R") 
load("si_sample_mcmc_Ali_Tk.R")

debug<-FALSE
theme_grid<-ggplot2::theme(panel.background = element_rect(fill = NA),
  panel.grid.major = element_line(colour = "grey70",size=1.1),
  panel.grid.minor = element_line(colour = "grey30",size=1)) 

theme_grid_light<-ggplot2::theme(panel.background = element_rect(fill = NA),
  panel.grid.major = element_line(colour = "grey90",size=1.1),
  panel.grid.minor = element_line(colour = "grey95",size=1)) 

#mondays 
mondaysdf<-data.frame(monday=seq(as.Date("2020-01-06"),as.Date("2022-01-03"),7),friday=seq(as.Date("2020-01-10"),as.Date("2022-01-07"),7))
add_weekdays<-function(plot,mondays=mondaysdf,mindate=min(mondaysdf$monday),maxdate=max(mondaysdf$monday),fill="pink",alpha=0.04,border=TRUE){
  df_selected<-subset(mondays,(monday<maxdate) & (monday>mindate)) 
  if (border)
  for (i in (1:nrow(df_selected))){plot<-plot+geom_rect(aes_string(xmin=df_selected[i,"monday"],xmax=df_selected[i,"friday"],ymin=0,ymax=Inf),fill=fill,alpha=alpha)}
  else
    for (i in (1:nrow(df_selected))){plot<-plot+geom_rect(aes_string(xmin=df_selected[i,"monday"],xmax=df_selected[i,"friday"],ymin=0,ymax=Inf),fill=fill,alpha=alpha,color=NA)}
return(plot)
  }

mi_kable<-function(dataframe,caption=NULL,digits=NULL,col.names=names(dataframe)){
  if(is.data.frame(dataframe)){
    if (row.names(dataframe)[c(1,2)]!=c("1","2")) dataframe <- dataframe %>% tibble::rownames_to_column(" ")
    
    ft<-set_header_labels(flextable(dataframe),col.names)
    
    }
  else ft<-as_flextable(dataframe)
  if(!is.null(digits)){
    numeric_cols<-c()
    for (col in colnames(dataframe)){
      if (is.numeric(cat)) numeric_cols<-c(numeric_cols,cat)
    }
    ft<-colformat_num(x=ft,j=numeric_cols,digits=digits)
  } 
  if(!is.null(caption)) ft<-add_header_lines(ft,values=c(caption)) 
  return (ft) 
} 
knitr::opts_chunk$set(echo = FALSE,cache = TRUE,error=FALSE,warning=FALSE,message=FALSE)
```

```{r GETDATA, echo = FALSE,error=FALSE,warning=FALSE,message=FALSE}
datasources[["Spain_regions"]]@df<-datasources[["Spain_regions"]]@getData(datasources[["Spain_regions"]])
msc_csv<-read.csv("https://cnecovid.isciii.es/covid19/resources/casos_tecnica_ccaa.csv",encoding="UTF-8",stringsAsFactors = TRUE)#,(FECHA!="") & (!(is.na(`PCR.`))))
cat_z<-read.csv(CAT_z_path,encoding="UTF-8",stringsAsFactors = TRUE)
USAs_csv<<-read.csv(USAs_path,encoding="UTF-8",stringsAsFactors = TRUE)   
datasources[["Spain_regions"]]@df$FECHA<-as.Date(datasources[["Spain_regions"]]@df$fecha,"%Y-%m-%d")
msc_csv_ag<-subset(read.csv("agregados.csv",encoding="UTF-8", stringsAsFactors = TRUE),(FECHA!="") & (!(is.na(`PCR.`)))) %>% dplyr::mutate(FECHA=as.Date(FECHA,"%d/%m/%Y"))
ccovid19<-read.csv("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv",encoding="UTF-8",stringsAsFactors = TRUE)
ccovid19$Province.State=NAtoAll(ccovid19$Province.State)
ccovid19$Country.Region <- plyr::revalue(ccovid19$Country.Region,c("South Africa"="S. Africa","United Kingdom"="UK"))

ecdc<-read.csv("https://opendata.ecdc.europa.eu/covid19/casedistribution/csv",stringsAsFactors = TRUE) %>% filter(countriesAndTerritories!="Cases_on_an_international_conveyance_Japan")

Peru<-datasources[["Peru"]]@getData(datasources[["Peru"]]) #Perú %>% filter(region=="* All *",is.na(pcr_positivo))
Peru_test<-read.csv("https://raw.githubusercontent.com/jmcastagnetto/covid-19-peru-data/main/datos/covid-19-peru-test-results.csv",encoding="UTF-8",stringsAsFactors = TRUE)
#Peru_test[(Peru_test$fecha==("2020-07-09")) & (Peru_test$personas==80761),"resultado"]<-"positivo"
Peru_test[(Peru_test$fecha==("2020-07-10")) & (Peru_test$personas==2020051),"personas"]<-202051
Peru_test$resultado<-as.factor(as.character(Peru_test$resultado))
#Peru_test[(Peru_test$fecha=="2020-04-11") & (Peru_test$resultado=="negativo") & (Peru_test$tipo_prueba=="moleculares"),"personas"] <- 22258
#Peru_test[(Peru_test$fecha=="2020-04-11") & (Peru_test$resultado=="negativo") & (Peru_test$tipo_prueba=="serológicas"),"personas"] <- 36606
#Peru_test[(Peru_test$fecha=="2020-04-27") & (Peru_test$resultado=="negativo") & (Peru_test$tipo_prueba=="moleculares"),"personas"] <- 39540
Peru_test[(Peru_test$fecha=="2020-09-01") & (Peru_test$resultado=="negativo") & (Peru_test$tipo_prueba=="serológicas"),
          "personas"]<-2637808-496549
Peru_test[(Peru_test$fecha=="2020-09-01") & (Peru_test$resultado=="negativo") & (Peru_test$tipo_prueba=="moleculares"),
          "personas"]<-595226-160580
  
ITA_test<-read.csv("https://raw.githubusercontent.com/pcm-dpc/COVID-19/master/dati-andamento-nazionale/dpc-covid19-ita-andamento-nazionale.csv",encoding="UTF-8",stringsAsFactors = TRUE)
#Mex <- read.csv("C:\\Users\\alfre\\OneDrive\\Documentos\\myR\\data\\200619COVID19MEXICO.csv",encoding="UTF-8")
Col<-read.csv("Casos_positivos_de_COVID-19_en_Colombia.csv", encoding="UTF-8", stringsAsFactors = TRUE) %>% mutate(Diagnostic.Delay = as.numeric(as.Date(Fecha.de.diagnóstico,"%d/%m/%Y")-as.Date(Fecha.de.inicio.de.síntomas,"%d/%m/%Y")), Report.Delay = as.numeric(as.Date(fecha.reporte.web,"%d/%m/%Y")-as.Date(Fecha.de.diagnóstico,"%d/%m/%Y"))) %>% mutate(Report.Delays=sapply(as.numeric(Report.Delay),function(Report.Delay){if (is.na(Report.Delay)) "NA" else if(Report.Delay<0) "<0" else if (Report.Delay==0) "0" else if (Report.Delay<6) "1 to 5" else ">5"}), month=as.factor(strftime(as.Date(Fecha.de.diagnóstico,"%d/%m/%Y"),"%m-%Y"))) %>%
                    dplyr::rename(Ethnicity=Pertenencia.étnica, Condition=Estado)# %>% dplyr::pivot_longer(cols=c(Diagnostic.Delay,Report.Delay),values_to="Time")
Col$Condition<-relevel(plyr::revalue(Col$Condition,c("leve"="Mild","LEVE"="Mild","Leve"="Mild","moderado"="Moderate","Moderado"="Moderate","Grave"="Severe","Fallecido"="Deceased","Asintomático"="Asymptomatic")),ref="Mild")
Col$Ethnicity[is.na(Col$Ethnicity)]=0
Col$Ethnicity<-plyr::revalue(as.factor(Col$Ethnicity),c("6"="Other","5"="Black","4"="Palenquero","3"="Raizal","2"="ROM","1"="Indigenous","0"="Not defined"))

US_test<-read.csv("https://covidtracking.com/api/v1/us/daily.csv",encoding="UTF-8", stringsAsFactors = TRUE)
OECD<-read.csv(paste("C:\\Users\\",userstring,"\\OneDrive\\Documentos\\myR\\REGION_ECONOM_25062020012657665.csv",sep=""), encoding="UTF-8", stringsAsFactors = TRUE)
Peru_PPC<-OECD %>% filter(MEAS =="PC_USD_PPP", Year =="2017",substr(REG_ID,1,2)=="PE")
USA_PPC<-OECD %>% filter(MEAS =="PC_USD_PPP", Year =="2018",substr(REG_ID,1,2)=="US")
ES_PPC<-OECD %>% filter(MEAS =="PC_USD_PPP", Year =="2017",substr(REG_ID,1,2)=="ES")
Cantabria_tests<-read.csv(paste("C:\\Users\\",userstring,"\\OneDrive\\Documentos\\myR\\Tests realizados.csv",sep=""),encoding="UTF-8", stringsAsFactors = TRUE)
CyL_tests<-read.csv("https://analisis.datosabiertos.jcyl.es/explore/dataset/pruebas-realizados-coronavirus/download/?format=csv&timezone=Europe/Madrid&lang=es&use_labels_for_header=true&csv_separator=%3B",encoding="UTF-8",sep=";", stringsAsFactors = TRUE)
world_bank<-read.csv("API_NY.GDP.PCAP.PP.KD_DS2_en_csv_v2_1218747.csv",encoding="UTF-8",skip=4, stringsAsFactors = TRUE) %>%
  dplyr::select(Country.Name,Country.Code,`X2017`,`X2018`,`X2019`)
world_bank$Country.Name <- plyr::revalue(world_bank$Country.Name,c("South Africa"="S. Africa","United Kingdom"="UK"))
Canada<-datasources[["Canada"]]@getData(datasources[["Canada"]])
Chiledif<<-read.csv("https://raw.githubusercontent.com/MinCiencia/Datos-COVID19/master/output/producto39/NotificacionInicioSintomas_T.csv",stringsAsFactors = FALSE,encoding="UTF-8")
colnames(Chiledif)<-make.names(paste(colnames(Chiledif),Chiledif[1,]))
Chiledif<-Chiledif[-1,]
EUTests<-read.xlsx("weekly_testing_data_EUEEAUK_2020-10-01_0.xlsx", skipEmptyRows=FALSE) %>%
  dplyr::mutate(date=as.Date(paste(year_week,"-1",sep=""),tryFormats="%Y-W%U-%u"))

```

**Abstract** 

An essential indicator of COVID-19 transmission is the effective reproduction number ($R_t$), the number of cases which an infected individual is expected to infect at a particular point in time; curves of the evolution of $R_t$ over time (transmission curves) reflect the impact of preventive measures and whether an epidemic is controlled. We have created a Shiny/R web application ([https://alfredob.shinyapps.io/estR0/](https://alfredob.shinyapps.io/estR0/)) with user-selectable features: open data sources with daily COVID-19 incidences from all countries and many regions, customizable preprocessing options (smoothing, proportional increment, etc), different MonteCarlo-Markov-Chain estimates of the generation time or serial interval distributions and state-of-the-art $R_t$ estimation frameworks (EpiEstim, R0). This application could be used as a tool both to obtain transmission estimates and to perform interactive sensitivity analysis.

We have analyzed the impact of these factors on transmission curves. We also have obtained curves at the national and sub-national level and analyzed the impact of epidemic control strategies, superspreading events, socioeconomic factors and outbreaks.  

Reproduction numbers showed earlier anticipation compared to active prevalence indicators (14-day cumulative incidence, overall infectivity). In the sensitivity analysis, the impact of different Rt estimation methods was moderate/small, and the impact of different serial interval distributions was very small. We couldn't find conclusive evidence regarding the impact of alleged superspreading events.  As a limitation, dataset quality can limit the reliability of the estimates.

The thorough review of many examples of COVID-19 transmission curves support the usage of $R_t$ estimates as a robust transmission indicator.  

# Introduction

The *basic reproduction number* ($R_0$) is the average number of secondary cases of an infectious disease caused by a single infected individual over his infectious period, when all individuals are susceptible to infection and in the absence of preventive measures. It depends on the transmissibility (probability of infection, given contact), the average rate of contacts and the average duration of the disease. The contact rate is influenced by demography, population density, cultural habits, seasonality... so the $R_0$ can vary widely [@Delamater2019]. In SIR models, the $R_0$ is the ratio between the effective contact rate and the removal rate.  
 
The *effective reproduction number* (here denoted as $R(t)$) is the actual number of cases that an infected individual is expected to infect at a particular point in time, given the current state of the population, and is typically smaller than $R_0$. $R(t)$ is influenced by mobility restrictions and confinement measures[@Arenas2020], and depends on the proportion of susceptible individuals.  

## Relevance as transmission indicators.

After the first COVID-19 pandemic outbreaks were controlled, many countries have implemented reopening scenarios requiring transmission indicators: The French Government defined three $R$ levels, green (<1), orange (1-1.5) or red (>1.5)[@FrenchGov]. In the Russian Federation the $R(t)$ was defined as a main indicator, along with bed availability and test capacity; initially proposed cutoffs for the $R(t)$ included $\le 1$ to advance to phase I, $\le 0.8$ to advance to phase II and $\le 0.5$ to advance to phase III [@ProtocoloRussia]. The WHO recognized a $R(t)$ as theoretically the best indication that an epidemic is controlled and declining, and recommended large countries should estimate it at subnational level[@WHOCriteria]. 

According to their objective, public health strategies can be classified in **mitigation**, that aims to slow down the transmission in order to prevent healthcare system collapse ("so that large numbers of people do not become ill at the same time"[@Sweden]), without necessarily stopping epidemic spread, thereby reaching $R(t)$ values close to 1; and **suppression**, which aims to reach $R(t)$<1, including more strict measures and quarantines, and which has been suggested as the recommended strategy for countries which are able to attain it because it would result in less deaths[@ImperialNPI2020]. 

Some superspreading events can correlate with $R(t)$ peaks[@Cori2013]. Superspreading patients (or events), those who allegedly transmit an infection to a large number of individuals, due to high viral load, asymptomatic cases and extensive social interactions [@AlTawfiq2020]; and they are associated with both early explosive growth and late sustained transmission[@Frieden2020]. Media have reported several events that might qualify as such (Atalanta-Valencia football match on 2020-02-19[@CBS2020], the 2020-03-08 events in Spain [@europapress_2020] (including International Women's Day demonstrations), the annual gathering of the Christian Open Door Church (14-24 February 2020) in Mulhouse, France, la Fête de la Musique also in France (2020-06-21), the Spring Break in USA (varying dates around March 7-14 2020)[@CNN_travel], the riots in USA after the death of George Floyd and the elections in Dominican Republic (5th July)[@Dominicana]).   

## Obtaining reproduction numbers

The generation time ($GT$) is needed to estimate reproduction numbers, it is the period between infection start in the infector and infection start in the infectee. As the $GT$ distribution is not easily determined, the serial interval($si$) is often used as a surrogate[@Griffin2020], with certain assumptions[@Lehtinen2020]. The $si$ is the interval between symptoms onset in the infector and symptoms onset in the infectee; it has the same mean as the $GT$, but larger variance due to the presence of presymptomatic transmission, with possible negative values[@Ganyani2020]. 

COVID-19 $si$ has been described as being shorter than the incubation period, implying that SARS-CoV-2 exhibits presymptomatic transmission. Estimations also exist for the $GT$, obtained from clusters from Singapore and Tianjin[@Ganyani2020]. The statistical distribution of the $GT$ or $si$ reveals the infectiousness profile, which is related to the viral shedding[@He2020]. 

$GT$s, epidemic growth rates and reproduction numbers are mathematically related[@Wallinga2006][@Fraser2007][@Wallinga2004]. In time-since-infection-models, different estimates exist for the time-varying effective reproduction numbers[@Fraser2007]: The **case reproduction number** at time $t$ ($R^c_t$), is the average number of cases an infected individual at time $t$ will infect; it is estimated with the method by Wallinga and Teunis[@Wallinga2004] and it reflects transmissibility after time $t$. On the other hand, the **instantaneous reproduction number** $R_t$ is the average number of people some individual infected at time $t$ could be expected to infect if conditions remain unchanged; it is estimated by the ratio of new infections generated at time $t$, to the total infectiousness at time $t$[@Cori2013].

## Other transmission indicators

**Empirical reproduction number** ${\rho}_{7}$ has been proposed[@Prats2020] as COVID-19 time-dependent empirical calculation, it is the 7-day-averaged $\rho_{t}$, calculated as ${\rho_{t}}=\frac{I_{t-1} + I_{t} + I_{t+1}}{I_{t-6} + I_{t-5}+I_{t-4}}$. A simpler estimate, which is also smoothed, uses the mean of the serial interval ($\tau$): $R_t\approx\frac{I_t}{I_{t-\tau}}$ [@Menendez2020].

**14-day cumulative incidence rates/100000 hab** (**$CIR_{14}$**) provides information on prevalence, and their variation reflects transmission; in Europe and Spain this has been a preeminent indicator([@ECDCsep2020RRA],[@BOEinterterritorial]).
**Overall infectivity** (OI) at time $t$ is the sum of previously infected individuals at that time, weighed by their infectivity (as calculated by the $si$ distribution)[@Cori2013]; if this is divided by the total population a more accurate estimate of prevalence could be obtained (the **OI ratio**). The slope between consecutive points in the log-scaled epidemic curve is the incidence rate ratio ($IRR=\frac{I_t}{I_{t-1}}=\log(I_t) - \log (I_{t-1})$). 

In this report we focus on the effective reproduction numbers as an indicator, and the curves of time-varying effective reproduction number vs time (**transmission curves**, as an analog of epidemic curves which display daily incidence data). Using an estimate as an indicator might raise concerns about its uncertainty, robustness, reliability, estimation methodology or easy calculation; in this paper we attempt to solve these concerns by facilitating calculation and assessing the impact of different factors on estimations.

# Materials and methods{#mm}

A web application to estimate $R_t$ and $R^c_t$ has been developed.  ([https://alfredob.shinyapps.io/estR0/](https://alfredob.shinyapps.io/estR0/)); combining state-of-the-art $R$ estimation packages, open COVID-19 incidence/prevalence datasets, $GT$ or $si$ descriptions (denoted as $GT$/$si$) and the Shiny webdev framework[@Shiny]. 

Many retrospective COVID-19 open data sources have been included in the application: official country datasets, world datasets, and semiofficial country datasets (compiled by volunteers from official sources); see Sup. material (abbreviated as SupM/) SupM/\@ref(SMM) for a list. 

COVID-19 cases are defined by having a positive PCR. Datasets can have many issues: corrections or consolidations (larger peaks or valleys), noise (smaller peaks and variability, maybe arising from a small number of tests), an uncertain time-dependent proportion of undetected cases (the **undetected rate**, suggested as 80-90% early in Iceland [@Stock2020], 72% in Italy[@Tuite2020] or 56.5% in Austria [@Bhning2020]), different delays between symptoms and report, etc. If health authorities report cumulative incidences every day ("number of cases so far"), a time series of approximate daily incidences is obtained by differentiation; this might introduce spurious peaks. Graphs and tables have been implemented in the application so that the user can examine the impact of the preprocessing steps, which include increasing daily incidence by a constant proportion, smoothing, negative values management and epidemic start. Several state of the art $si$ and $GT$ distributions have also been implemented, (lognormal, gamma, truncated normal, etc). When the original authors dataset is available ([@Nishiura2020], [@Zhao2020], [@Du2020], [@Ali2020]), MCMC is used to obtain a lognormally-distributed distribution or multiple distributions to account for uncertainty; when point estimates with intervals are available both the estimates and multiple distributions are obtained via bootstrapping ([@Ganyani2020], [@Ali2020]) (SupM/\@ref(SMM)).  

Single and multiple distributions are used to estimate $R_t$ (R package EpiEstim[@Thompson2019][@Cori2013]), and single distributions are used to estimate $R_t^c$ ([@Wallinga2004], R0 package[@R0]). Overall infectivity (as estimated with EpiStim and point distributions), $CIR_7$ and $CIR_14$ are provided as cumulative incidence indicators.  The code of the application is shared upon publication at [https://github.com/AlfredoBB/EstRt](https://github.com/AlfredoBB/EstRt)  

This code and application are applied to several incidence datasets (world countries and regions in Spain, Belgium, USA, Perú and Germany) to confirm the validity and reliability of the curves over a wide set of incidence data and to look for answers to several questions by looking at examples: 

 **A: What impact does data quality have on $R_t$ estimations?** Transmission curves are compared according to the data source (epidemiological reports versus cumulative incidence, (Spain, SupM/\@ref(RENAVE)), presence of spurious peaks SupM/\@ref(spuriouspeaks)), the impact of weekends and smoothing (Belgium SupM/\@ref(smoothBelgium), Catalonia SupM/\@ref(CatSmooth)), etc. 

 **B: What impact do preprocessing parameters have on $R(t)$ estimations?** Transmission curves have been obtained with different smoothing and preprocessing settings. A rudimentary one-at-a-time sensitivity analysis is also performed (SupM/\@ref(OAT)) using as an indicator the $gap$ between curves: the sum of squared differences between non-overlapping credible intervals of same-date $R_t$ estimates is obtained, and daily average of this difference is calculated; the closer to zero the $gap$ gets, the more similar the curves are. This analysis is performed with varying smoothing spans, and proportions of undetected cases.  

 **Question C: What impact do the different $si$s/$GT$s and estimation methods have?** Transmission curves for different $si$/$GT$ distributions and estimation methods ($R_t$,$R_t^c$,$\rho_7$) have been analyzed, and other transmission indicators ($CIR_{14}$, and OI ratio, with population from [@WorldPop]) are shown. The daily $gap$ between curves is used to analyze the impact of the $GT$ distributions, and the different priors distributions(SupM/\@ref(OATsi)). Hierarchical clustering has been applied to the curves obtained with different $si$/$GT$. 

 **Question D: What impact do wealth and development have on national transmission curves?** We obtained examples of transmission curves of developed and developing countries[@WorldBankBook] with data from the (JHU-CSSE dataset). GDP per capita (PPP, constant 2017 international dollars) from World Bank data from 2019 (2017 for Iran) [@WorldBank] is used to colour the transmission curves. 

 **Question E: Do transmission curves follow similar patterns on sub-national/regional level?** 
Several examples of transmission curves at sub-national/regional levels have been obtained (USA, Spain, Perú, Belgium, Germany and Catalonia). Hierarchical clustering using the $gap$ as distance is also applied for USA and Spain. 

 **Question F: Are transmission curves altered in/near suspected superspreading events?** Their impact has been analyzed in Italy, Spain, France, USA and Dominican Republic. Some of these events have been subjects of political debate; but the question examined here has an epidemiological nature. 

 **Question G: Can transmission curves be used to detect outbreaks?** we have analyzed the relation between outbreaks and $R_t$ in July 2020 (Sup. material, Germany, SupM/\@ref(Germany); Catalonia, SupM/\@ref(CatOutbreaks), which also includes a sensitivity analysis with several $si$ or $GT$ distributions, and other indicators ($CIR_{14}$, OI ratio, $\rho_{7}$).  

Many of these questions are mutually related: Data quality influences estimations, national superspreading events can also be analyzed on the sub-national level, COVID-19 data quality can be influenced by economic factors, subnational calculations can show the impact of local outbreaks, etc. i.e. a "many-to-many" relationship between examples and conclusions is central and guides this study. Ultimately, these conclusions are 

The peer-analysis of the temporal evolution of the $R_t$ (transmission curves) here is mostly performed qualitatively on the examples, considering the epidemiological implications: $R_t$ trends and control level (R<1), classifying the visual differences curves in **"virtually nonexistent"**, **"noticeable"** and **"clinically-relevant"**. 

# Results

A summary of the results is shown in Table \@ref(tab:resulta); detailed curves and gap tables are available in the Sup. Material. 

```{r resulta}
resultados<-data.frame() %>% mutate(issue=NA,analysis=NA,results = NA) 
resultados["A) Data Quality",]<-c("A) Data Quality","Delays (Colombia), negative values (JHU dataset), Spain and Catalonia curves comparison","Problems include: Incidences obtained from cumulative data, reporting delays, poor documentation, aggregation of positives from different tests, etc.\nData quality determines estimates quality")
resultados["A) Underreporting",]<-c("A) Underreporting","Test positivity","Differences by location and time-period; this is relevant for comparisons")
resultados["B) Smoothing method",]<-c("B) Smoothing method","curves comparison","Smoothing data is a possible workaround for excessive data variability and spurious peaks, and for weekday-weekend bias. Lowess is 'less predictable' than SMA")
resultados["B) Smoothing span",]<-c("B) Smoothing span","Calculated gap, curves comparison","Barely any mathematical differences; small visual differences.")
resultados["B) Other preprocessing",]<-c("B) Other preprocessing","Calculated gap, curves comparison","The priors did not have any impact, increasing incidences by a constant proportion narrowed credible intervals without modifying the curves")
resultados["C) GT or SI",]<-c("C) GT or SI","Calculated gap, curves comparison","Small differences between longer and shorter intervals; with very scant clinical relevance")
resultados["C) Rt Estimation methods",]<-c("C) Rt Estimation methods","curves comparison (world countries, Spain, Belgium, Catalonia)","Small differences between estimations and simplified calculations, sometimes with clinical relevance. EpiEstim showed consistent results.")
resultados["D) Impact of GDP per capita",]<-c("D) Impact of GDP per capita","curves comparison","Wealthier countries succeeded better in reaching suppresion levels.")
resultados["E) Subnational estimations",]<-c("E) Subnational estimations","curves comparison","Useful for larger subdivisions. Rt surges can detect outbreaks.")
resultados["F) Superspreading events",]<-c("F) Superspreading events","curves comparison","Rt is either unaffected, or not conclusively affected, or estimates are unavailable.")
resultados["G) Outbreak detection",]<-c("G) Outbreak detection","curves comparison (world countries, Spain, Belgium, Catalonia, Germany)","$CIR_{14}$ or OI ratio lack the anticipation provided by Rt. Rt is unstable and can show surges in low-incidence situations.")

flextable(resultados) %>% add_header_lines("Summary of results")

```

## Question A: Data quality 

Some countries have reported positive peaks or negative values (SupM/\@ref(datapeaks)), so initial visual exploration of the daily incidences is essential, as available in the application. The proportion of positive tests has significantly changed over the course of weeks/months (Figure: \@ref(fig:testsEU), source: ECDC weekly data on COVID-19 testing), (SupM/\@ref(Tests)).  

Secondly, there are several time intervals: infection-symptoms (incubation period), symptoms-diagnosis (diagnosis delay), diagnosis-report (report delay). Delays have been analyzed in the Colombia dataset (SupM/\@ref(delays)); a small temporal association has been found. In Spain these delays vary between regions and also changed over time (median (IQR) diagnosis delay: first-wave: 5 (3-11) days [@RENAVEdatos]; second-wave: 3 (2-5) days [@RENAVEdatosOctubre]). Using symptoms-onset dates improves the time-series and reduces variability(SupM/\@ref(RENAVE)). 

```{r graphs-calc}
US_graph<-US_test %>% mutate(date=as.Date(as.character(date),"%Y%m%d")) %>% dplyr::arrange(date) %>%
  mutate(negativeIncrease_=negative-lag(negative),positiveIncrease_=positive-lag(positive),
         totalTestResultsIncrease_=totalTestResults-lag(totalTestResults),
  percent_pos=positiveIncrease_/totalTestResultsIncrease_*100) %>%
  dplyr::select(c(date,percent_pos,positiveIncrease,negativeIncrease)) %>%
  tidyr::pivot_longer(-date,names_to="type",values_to="tests") %>%
  mutate(val=ifelse(type=="percent_pos","Pos. Percentage","Number of tests")) %>%
  mutate(type=ifelse(type=="negativeIncrease","Negatives","Positives")) %>% filter (date>as.Date("2020-03-15"))

US_graph[US_graph$tests<0,'tests']<-0

Peru_test[(Peru_test$fecha=="2020-07-31") & (Peru_test$resultado=="negativo") & (Peru_test$tipo_prueba=="serológicas"),"personas"] <- NA
Peru_test[(Peru_test$fecha=="2020-08-01") & (Peru_test$resultado=="negativo") & (Peru_test$tipo_prueba=="serológicas"),"personas"] <- NA

Peru_test_pct<-Peru_test %>% drop_na() %>%
  tidyr::pivot_wider(id_cols=c(fecha,tipo_prueba),names_from=c(resultado),values_from=personas) %>%  group_by(tipo_prueba) %>% dplyr::arrange(as.Date(fecha)) %>% mutate(positivo=positivo-lag(positivo,default=0),negativo=negativo-lag(negativo,default=0)) %>% mutate (percent_pos=positivo/(positivo+negativo)*100) %>% dplyr::ungroup() %>% tidyr::pivot_longer(-c(1,2),names_to="Result",values_to="Tests") %>%
  mutate(val=ifelse(Result=="percent_pos","Daily Positives (%)","Daily count")) %>% mutate(Result=ifelse(Result=="negativo","negative","positive"), type=ifelse(tipo_prueba=="moleculares","PCR","Serology"),
 fecha=as.Date(fecha)) %>% rename(Date=fecha) %>% filter(Date!=as.Date("2020-04-08"))

CanadaGraph <- Canada %>% group_by(prname) %>% mutate (date=as.Date(date,"%d-%m-%Y")) %>%
    dplyr::arrange(date) %>%
    mutate(Tests=numtests-lag(numtests),PositiveTests=numconf-lag(numconf)) %>%
    mutate(PositiveRate = PositiveTests/Tests*100) %>% dplyr::ungroup() %>%
    dplyr::select(prname,date,Tests,PositiveTests,PositiveRate) %>%
    tidyr::pivot_longer(-c(1:2),names_to="Variable",values_to="Tests") %>%
    mutate(Values=ifelse(Variable=="PositiveRate","Percentage","Count of tests")) %>%
    mutate(Variable=ifelse(Variable=="PositiveRate","PositiveTests",Variable))

Cantabria_tests <- Cantabria_tests %>% group_by(Variables) %>% mutate(Type=Variables,Tests=Valor - lag(Valor),Date=as.Date(Fecha)) %>% dplyr::ungroup() %>% filter(Date!=min(Date)) %>% mutate(Type=ifelse(Type=="Test PCR","PCR","Antibodies"))

CyL_tests_ <- CyL_tests  %>% dplyr::select (c(Fecha,Provincia,test_rapidos_positivos,test_rapidos_total,test_porcentaje,pcr_positivos,pcr_total,pcr_porcentaje)) %>%
  mutate(Fecha=as.Date(Fecha)) %>% dplyr::arrange(Fecha)%>% group_by (Provincia)%>% 
           mutate(total_antibodies=test_rapidos_total-lag(test_rapidos_total),positive_antibodies=test_rapidos_positivos-lag(test_rapidos_positivos),total_pcr=pcr_total-lag(pcr_total), positive_pcr=pcr_positivos-lag(pcr_positivos)) %>% ungroup() %>% mutate(`positive(%)_antibodies`=positive_antibodies/total_antibodies*100, `positive(%)_pcr`=positive_pcr/total_pcr*100,Date=Fecha) %>%
  mutate(negative_antibodies=total_antibodies-positive_antibodies, negative_pcr=total_pcr-positive_pcr)%>%
  dplyr::select(c(Date,Provincia,total_pcr,positive_pcr,negative_pcr,`positive(%)_pcr`,total_antibodies,positive_antibodies,negative_antibodies,`positive(%)_antibodies`)) %>%
  pivot_longer(-c(1,2),names_to="Result_Type",values_to="Tests") %>%
  mutate(Type=ifelse(Result_Type %in% c("positive_pcr","positive(%)_pcr","total_pcr","negative_pcr"),"PCR","Antibodies"),
         Result=ifelse(Result_Type %in% c("positive_pcr","positive(%)_pcr","positive_antibodies","positive(%)_antibodies"),"Positive", ifelse(Result_Type %in% c("negative_pcr","negative(%)_pcr","negative_antibodies","negative(%)_antibodies"), "Negative","Total"))) %>%
    mutate(Val=ifelse(Result_Type %in% c("negative(%)_pcr","positive(%)_pcr","positive(%)_antibodies"),"Percentage","Count of tests")) %>% filter(Date<as.Date("2020-06-19"))

```

```{r testsEU,fig.cap="\\label{fig:testsEU}Positivity rate for large European countries",fig.width=7,fig.height=5}
#EUTests<-EUTests %>%mutate(lty=factor(as.numeric(EUTests$Country)%%7+1),shape=factor(as.numeric(EUTests$Country)%%6+1)) %>% tidyr::drop_na(c(positivity_rate,Country))
ggarrange(ggplot(data=EUTests %>%dplyr::filter(population>10.5*10^6,as.Date(date)>as.Date("2020-02-16")), aes(x=date,y=positivity_rate,colour=Country))+
            geom_line(size=1.5)+
              geom_point(size=2)+
            scale_colour_brewer(type="qual",palette="Paired")+my_theme_13+labs(x= "Date",y="Positivity rate")
            #scale_shape_manual(name="Country",values=(seq(1:32)%%6+1),labels=levels(EUTests$Country),drop=FALSE) +
          #scale_linetype_manual(name="Country",values=(seq(1:32)%%7+1),labels=levels(EUTests$Country),drop=FALSE) +
          #scale_colour_manual(name="Country",values=(seq(1:32)),labels=levels(EUTests$Country))
            )

```

## Question B: Preprocessing.

Preprocessing options did have a minor/moderate impact on transmission curves (SupM/\@ref(preproSpain), SupM/\@ref(OAT)). Naïvely multiplying each daily incidence by a constant factor to correct the undetected proportion is associated with virtually nonexistent changes in the $R_t$ curves (as previously described[@Cori2013]), although it reduces the Credible Intervals. 

Smoothing mildly influenced the final $R_t$ curves, but their characteristics and relevant trends (faster or slower decrease and epidemic control) remained unchanged and $gap$ between curves with different smoothing spans were only apparent when comparing far-apart values (no smoothing vs 9-day span). Spurious peaks (SupM/\@ref(CatSmooth)) or weekend-inactivity (SupM/\@ref(smoothBelgium)) directly translate into estimates, and could potentially cause clinically-relevant differences, thus providing a rationale for considering either time series smoothing, with the \fontcolor{red}{assumption that a smoothed time series better reflects the actual incidence}, or indicator smoothing via parameters.  

## Question C: $GT$/$si$ and estimation method  

```{r fdates}
start_date<-as.Date("2020/02/20")
end_date<-as.Date("2021/02/28"   ) 
```

Figure \@ref(fig:factores) shows the influence of different $GT$/$si$ distributions and estimation methods on the transmission curves, estimated with the JHU dataset (incidences between `r format(start_date,"%d-%b-%Y")` and
`r format(end_date,"%d-%b-%Y")`), without smoothing. 

```{r factoresc,eval=TRUE}
    
#moderesults=list(data_to_plot_modes=data.frame(matrix(NA,nrow=0,ncol=9)),estimates_modes=list())

#colnames(moderesults[["data_to_plot_modes"]])<-make.names(c("Country","Method","distr","Mode","date_start","date_end","Mean(R)","Quantile.0.025(R)","Quantile.0.975(R))"))
window<-7; 

Spain<-fdf_to_inci(ccovid19[(ccovid19$Country.Region=="Spain") & (ccovid19$Province.State=="* All *"),] %>%
                        dplyr::select(-c("Province.State","Country.Region","Lat","Long")) %>% t() %>%
                        as.data.frame() %>% dplyr::rename(Cum=1) %>% tibble::rownames_to_column("dates"),"X%m.%d.%y")
US<-fdf_to_inci(ccovid19[(ccovid19$Country.Region=="US") & (ccovid19$Province.State=="* All *"),] %>%
                        dplyr::select(-c("Province.State","Country.Region","Lat","Long")) %>% t() %>%
                        as.data.frame() %>% dplyr::rename(Cum=1) %>% tibble::rownames_to_column("dates"),"X%m.%d.%y")
Italy<-fdf_to_inci(ccovid19[(ccovid19$Country.Region=="Italy") & (ccovid19$Province.State=="* All *"),] %>%
                        dplyr::select(-c("Province.State","Country.Region","Lat","Long")) %>% t() %>%
                        as.data.frame() %>% dplyr::rename(Cum=1) %>% tibble::rownames_to_column("dates"),"X%m.%d.%y")
Brazil<-fdf_to_inci(ccovid19[(ccovid19$Country.Region=="Brazil") & (ccovid19$Province.State=="* All *"),] %>%
                        dplyr::select(-c("Province.State","Country.Region","Lat","Long")) %>% t() %>%
                        as.data.frame() %>% dplyr::rename(Cum=1) %>% tibble::rownames_to_column("dates"),"X%m.%d.%y")
UK<-fdf_to_inci(ccovid19[(ccovid19$Country.Region=="UK") & (ccovid19$Province.State=="* All *"),] %>%
                        dplyr::select(-c("Province.State","Country.Region","Lat","Long")) %>% t() %>%
                        as.data.frame() %>% dplyr::rename(Cum=1) %>% tibble::rownames_to_column("dates"),"X%m.%d.%y")
India<-fdf_to_inci(ccovid19[(ccovid19$Country.Region=="India") & (ccovid19$Province.State=="* All *"),] %>%
                        dplyr::select(-c("Province.State","Country.Region","Lat","Long")) %>% t() %>%
                        as.data.frame() %>% dplyr::rename(Cum=1) %>% tibble::rownames_to_column("dates"),"X%m.%d.%y")

moderesults<-comparemodes(list(Spain=incidf_prepro(incidf=Spain %>% dplyr::filter(dates>=start_date,dates<=end_date),
                      undetected=0.0, smooth_method="none", smooth_value=3, ignore=15,warnings="",negatives=dbfs)$df,
             US=incidf_prepro(incidf=US %>% dplyr::filter(dates>=start_date,dates<=end_date),
                      undetected=0.0,  smooth_method="none", smooth_value=3, ignore=15,warnings="",negatives=dbfs)$df,
             Brazil=incidf_prepro(incidf=Brazil %>% dplyr::filter(dates>=start_date,dates<=end_date),
                      undetected=0.0,  smooth_method="none", smooth_value=3, ignore=15,warnings="",negatives=dbfs)$df,
             India=incidf_prepro(incidf=India %>% dplyr::filter(dates>=start_date,dates<=end_date),
                      undetected=0.0,  smooth_method="none", smooth_value=3, ignore=15,warnings="",negatives=dbfs)$df),
             mode="none",distributions=c("Du", "Nishiura","Zhao","Ganyani Singapore","Ganyani Tianjin","Liu","Li","Ali early", "Ali late"),with_inci=TRUE,with_n_cum=14,with_rho7 = TRUE,TD="TD")
                        
###############################################################################

# No smoothing, no augmentation
```

```{r factores,fig.cap="\\label{fig:factores}Calculated transmission indicators: rho_7, 14-day notification rate, R(t)s calculated with different methods and distributions.  GT descriptions are included (Gany. S: Ganyani Singapore; Gany. T: Ganyani Tianjin). Interpretation: Noticeable differences and some clinical differences exist between estimates, and between those calculated with longer longer $si$s (Ali (late isolation cases), Li), which provide smoother estimations, and other $si$s. Larger datasets for MCMC provide narrower credible intervals.",fig.width=8,fig.height=11}
 
#
moderesults$data_to_plot[moderesults$data_to_plot["distr"]=="Ganyani Tianjin","distr"]<-"Gany. T."
moderesults$data_to_plot[moderesults$data_to_plot["distr"]=="Ganyani Singapore","distr"]<-"Gany. S."
 

ggarrange(
  ggarrange(ggplot(moderesults$empiricalR, aes(x = dates, y = as.numeric(`rho7`), group = Country)) +
    geom_line(aes(y = rho7, color=Country),size=1.1) +
    geom_hline(yintercept=1, linetype="dashed",  color = "black", size=1.05) +
    #ggtitle("Estimated R") +
    labs(y="rho_7") + ylim(c(0.5,3.5)) +
    my_theme_12 + ggplot2::theme(legend.position = "none", axis.title.x=element_blank()) +
  scale_colour_brewer(  type = "qual", palette = "Set1", direction = 1, aesthetics = "colour"),
  ggplot(moderesults$n_cum, aes(x = dates, y = as.numeric(`Ind`), group = Country)) + 
    geom_line(aes(y = Ind, color=Country),size=1.1) +
    #geom_hline(yintercept=1000, linetype="dashed",  color = "black", size=1.05) +
    geom_hline(yintercept=500, linetype="dashed",  color = "black", size=1.05) +
    geom_hline(yintercept=250, linetype="dashed",  color = "black", size=1.05) +
    #ggtitle("Estimated R") +
    labs(x= "Date",y="14d Inc/100000") + 
    my_theme_12 + ggplot2::theme(legend.position = "none",axis.title.x=element_blank()) + 
  scale_colour_brewer(  type = "qual", palette = "Set1", direction = 1, aesthetics = "colour"),ncol=2),
  ggplot(moderesults$data_to_plot, aes(x = date_end, y = as.numeric(`Mean.R.`), group = interaction(as.factor(Mode),Country))) +
    geom_line(aes(y = Mean.R.,color=Country),size=1.1) +
    geom_ribbon(aes(ymin = `Quantile.0.025.R.`, ymax = `Quantile.0.975.R.`, fill = "95%CrI",color=Country),alpha=0.1) +
    geom_line(aes(y = `Quantile.0.025.R.`,color=Country),linetype=2,alpha=0.7) +
    geom_line(aes(y = `Quantile.0.975.R.`,color=Country),linetype=2,alpha=0.7) +
    geom_line(aes(y = Mean.R.,color=Country),size=1.3,alpha=0.8) +
    geom_hline(yintercept=1, linetype="dashed",  color = "black", size=1.05) +
    #ggtitle("Estimated R") +
    labs(y="Estimated R") + geom_line(aes(y = Mean.R.),color="black",size=0.1,alpha=0.8) + ylim(c(0.5,3.5)) +
    my_theme_12 + theme_bottom_legend + ggplot2::theme(axis.title.x=element_blank()) +
  scale_colour_brewer(  type = "qual", palette = "Set1", direction = 1, aesthetics = "colour") + facet_grid(rows=vars(distr), cols=vars(Method))
  ,nrow=2,heights=c(2,11))
  
```

A visible delay was observed when estimating the $R_t$ (vs $R^c_t$); by default, the EpiEstim package calculates the $R_t$ over a window period of seven days and this has been assigned to the last date of the period. $R^c_t$ are not calculated over window periods and exhibited somewhat higher variability. $si$ obtained early in the epidemic (Li et al[@Li2020]) rendered curves similar to those obtained with late-isolation cases in the Ali et al dataset[@Ali2020], as shown in the clustering(SupM/\@ref(hclust)). The influence of the $GT$/$si$ seems mild and all transmission curves reach similar epidemiological conclusions. Other sensitivity analysis yielded the same results (SupM/\@ref(CatOutbreaks)).

```{r oats_prep}

compareCrI<-function(X,Y,distance=FALSE){
  XY<-merge(X,Y, by="date_end",all=FALSE)
  if(distance)
    return(sum((XY$Mean.R..x - XY$Mean.R..y)^2)/nrow(XY))
    else
  return(sum(as.numeric(XY$Quantile.0.025.R..x > XY$Quantile.0.975.R..y) * (XY$Quantile.0.025.R..x - XY$Quantile.0.975.R..y)^2 + as.numeric(XY$Quantile.0.025.R..y > XY$Quantile.0.975.R..x) * (XY$Quantile.0.025.R..y - XY$Quantile.0.975.R..x)^2)/nrow(XY))
}

triangulardf<-function(df,digits=3){
  df<-round(df,digits=3)
  df[upper.tri(df)]<-""
  df[1,1]<-"0"
  return(df)
}

oats_func_loc<-function(incidf,locvar="Region",exclude_regions=c("Northern Mariana Islands"), get_data_method=function(df,i){fdf_to_inci(df[df[,locvar]==i,] %>% mutate (dates=as.Date(date,"%Y-%m-%d"),Cum=cases))}){
  cached_datas<-cached_curves<-list()
  locs<-setdiff(if (is.factor(incidf[,locvar])) levels(incidf[,locvar]) else unique(incidf[,locvar]),exclude_regions)
  oats<-as.data.frame(matrix(NA,nrow=length(locs),ncol=length(locs)));
  colnames(oats)<-rownames(oats)<-locs
  for (i in locs){
    cached_datas[[i]]<-get_data_method(df=incidf,i=i)
  }
  for (i in locs){
    for (j in locs){
      if(is.na(oats[i,j])){
        if (!(i %in% names(cached_curves))) {cached_curves[[i]]<- future(calculate_R(incidf= cached_datas[[i]], smooth=2,undetected=0, distribution="Du"),seed=TRUE)}
        if (!(j %in% names(cached_curves))) {cached_curves[[j]]<- future(calculate_R(incidf= cached_datas[[j]], smooth=2,undetected=0, distribution="Du"),seed=TRUE)}
      }
    }
  }
  value(cached_curves)
  #cached_curves_b %<-% cached_curves
  for (i in locs){
    for (j in locs){
      oats[i,j]<-oats[j,i]<-if (i==j) 0 else {compareCrI(value(cached_curves[[i]]), value(cached_curves[[j]]), distance=FALSE)}
    }
  }
  return(oats)
}


oats_func_distr<-function(incidf){
  cached_curves<-list()
  distribuciones_sens<-c("Du","Nishiura","Zhao","Ali","Ali early","Ali late","Ganyani Singapore","Ganyani Tianjin","Du Point","Nishiura Pt","Zhao Pt","Ali Pt","Ali early Pt","Ali late Pt","Ganyani Singapore Pt","Ganyani Tianjin Pt","Liu","Li")
  oats<-as.data.frame(matrix(NA,nrow=length(distribuciones_sens),ncol=length(distribuciones_sens)));
  colnames(oats)<-rownames(oats)<-distribuciones_sens
  for (i in distribuciones_sens){
    for (j in distribuciones_sens){
      if(is.na(oats[i,j])){
        if (!(i %in% names(cached_curves))) {cached_curves[[i]]<-future(calculate_R(incidf=incidf, smooth=4,undetected=0, distribution=i),seed=TRUE)}
        if (!(j %in% names(cached_curves))) {cached_curves[[j]]<-future(calculate_R(incidf=incidf, smooth=4,undetected=0, distribution=j),seed=TRUE)}
      }
    }
  }
  value(cached_curves)
  #cached_curves_b %<-% cached_curves
  for (i in distribuciones_sens){
    for (j in distribuciones_sens){
      oats[i,j]<-oats[j,i]<-if (i==j) 0 else {compareCrI(value(cached_curves[[i]]), value(cached_curves[[j]]), distance=FALSE)}
    }
  }
  return(oats)
}


start_date_oat<-as.Date("2020-03-10")
end_date_oat<-as.Date("2021-06-10"  )


Spain_oat<-fdf_to_inci(ccovid19[(ccovid19$Country.Region=="Spain") & (ccovid19$Province.State=="* All *"),] %>%
                        dplyr::select(-c("Province.State","Country.Region","Lat","Long")) %>% t() %>%
                        as.data.frame() %>% dplyr::rename(Cum=1) %>% tibble::rownames_to_column("dates"),"X%m.%d.%y") %>%
                        dplyr::filter(dates>=start_date_oat,dates<=end_date_oat)
US_oat<-fdf_to_inci(ccovid19[(ccovid19$Country.Region=="US") & (ccovid19$Province.State=="* All *"),] %>%
                        dplyr::select(-c("Province.State","Country.Region","Lat","Long")) %>% t() %>%
                        as.data.frame() %>% dplyr::rename(Cum=1) %>% tibble::rownames_to_column("dates"),"X%m.%d.%y") %>%
                        dplyr::filter(dates>=start_date_oat,dates<=end_date_oat)
Italy_oat<-fdf_to_inci(ccovid19[(ccovid19$Country.Region=="Italy") & (ccovid19$Province.State=="* All *"),] %>%
                        dplyr::select(-c("Province.State","Country.Region","Lat","Long")) %>% t() %>%
                        as.data.frame() %>% dplyr::rename(Cum=1) %>% tibble::rownames_to_column("dates"),"X%m.%d.%y") %>% 
                        dplyr::filter(dates>=start_date_oat,dates<=end_date_oat)
Brazil_oat<-fdf_to_inci(ccovid19[(ccovid19$Country.Region=="Brazil") & (ccovid19$Province.State=="* All *"),] %>%
                        dplyr::select(-c("Province.State","Country.Region","Lat","Long")) %>% t() %>%
                        as.data.frame() %>% dplyr::rename(Cum=1) %>% tibble::rownames_to_column("dates"),"X%m.%d.%y") %>% 
                        dplyr::filter(dates>=start_date_oat,dates<=end_date_oat)
Russia_oat<-fdf_to_inci(ccovid19[(ccovid19$Country.Region=="Brazil") & (ccovid19$Province.State=="* All *"),] %>%
                        dplyr::select(-c("Province.State","Country.Region","Lat","Long")) %>% t() %>%
                        as.data.frame() %>% dplyr::rename(Cum=1) %>% tibble::rownames_to_column("dates"),"X%m.%d.%y") %>% 
                        dplyr::filter(dates>=start_date_oat,dates<=end_date_oat)
UK_oat<-fdf_to_inci(ccovid19[(ccovid19$Country.Region=="UK") & (ccovid19$Province.State=="* All *"),] %>%
                        dplyr::select(-c("Province.State","Country.Region","Lat","Long")) %>% t() %>%
                        as.data.frame() %>% dplyr::rename(Cum=1) %>% tibble::rownames_to_column("dates"),"X%m.%d.%y") %>% 
                        dplyr::filter(dates>=start_date_oat,dates<=end_date_oat)
India_oat<-fdf_to_inci(ccovid19[(ccovid19$Country.Region=="India") & (ccovid19$Province.State=="* All *"),] %>%
                        dplyr::select(-c("Province.State","Country.Region","Lat","Long")) %>% t() %>%
                        as.data.frame() %>% dplyr::rename(Cum=1) %>% tibble::rownames_to_column("dates"),"X%m.%d.%y") %>% 
                        dplyr::filter(dates>=start_date_oat,dates<=end_date_oat)
Colombia_oat<-fdf_to_inci(ccovid19[(ccovid19$Country.Region=="Colombia") & (ccovid19$Province.State=="* All *"),] %>%
                        dplyr::select(-c("Province.State","Country.Region","Lat","Long")) %>% t() %>%
                        as.data.frame() %>% dplyr::rename(Cum=1) %>% tibble::rownames_to_column("dates"),"X%m.%d.%y") %>% 
                        dplyr::filter(dates>=start_date_oat,dates<=end_date_oat)

plan(multisession,workers=6)
```

```{r oats_dist_calc}


oats_Sp<-oats_func_distr(Spain_oat)
oats_Br<-oats_func_distr(Brazil_oat)
oats_USA<-oats_func_distr(US_oat)
oats_UK<-oats_func_distr(UK_oat)
oats_Russia<-oats_func_distr(Russia_oat)
oats_Colombia<-oats_func_distr(Colombia_oat)
oats_India<-oats_func_distr(India_oat)
```

We select the $R_t$ (EpiEstim) as an estimate and the Du et al-derived[@Du2020] MCMC distributions as $si$, as defaults for this study. 

## Question D. Results in several countries {#dev-nondev-countries}

```{r echo=FALSE,message=FALSE,warning=FALSE}
invisible(gc())

```

```{r cov1, echo=FALSE}
  
EU<-list(Brazil="Brazil",Belgium="Belgium",France="France",Germany="Germany",Iran="Iran",Italy="Italy",Japan="Japan",Sweden="Sweden",United_Kingdom="UK", Russia="Russia",India="India",South_Africa="S. Africa",Spain="Spain",Singapore="Singapore",US="US",Colombia="Colombia",Mexico="Mexico",Chile="Chile",Pakistan="Pakistan",Bangladesh="Bangladesh",Peru="Peru") #Ukraine="Ukraine",

Developed_countries<-c("Belgium","Germany","Italy","Sweden","Japan","UK","Portugal","Singapore","Spain","US","Netherlands","France")

start_date<-as.Date("2020-03-01")
end_date<-as.Date("2021-06-10"  ) 
 
#estimates<-list();
#incidences<-data.frame()
#countries_data_to_plot<-data.frame(matrix(NA,nrow=0,ncol=6))
#colnames(countries_data_to_plot)<-make.names(c("Country","date_start","date_end","Mean(R)","Quantile.0.025(R)","Quantile.0.975(R))"))
#source("libraryP.R")
window<-7;
EUcountries<-list()

for (country in EU){
  EUcountries[country]<-incidf_prepro(incidf=fdf_to_inci(ccovid19[(ccovid19$Country.Region==unlist(country)) & (ccovid19$Province.State=="* All *"),] %>%
                        dplyr::select(-c("Province.State","Country.Region","Lat","Long")) %>% t() %>%
                        as.data.frame() %>% dplyr::rename(Cum=1) %>%
                          tibble::rownames_to_column("dates"),"X%m.%d.%y") %>%
    dplyr::filter(dates>=start_date,dates<=end_date), undetected=0, positives="Do nothing",smooth_method="SMA (centered)",
    smooth_value=5,ignore=30,warnings="",negatives=dbfs)
};

world_results <- comparemodes(countries = EUcountries,mode = "European Union",windows = 7,
                              distributions = "Du",
             with_inci = TRUE, with_rho7 = TRUE, TD="TD", with_n_cum=14)

#world_results$data_to_plot

world_results$incidences <- world_results$incidences %>% mutate(dev=ifelse(Country %in% Developed_countries,"Developed","Developing"),
                                          wkd=as.numeric(strftime(dates,"%u")<6 ))

world_results$data_to_plot <- world_results$data_to_plot %>% mutate(dev=ifelse(Country %in% Developed_countries,"Developed","Developing"),
                                          wkd=as.numeric(strftime(date_end,"%u")<6 ))

 
lockdowns<-as.data.frame(matrix(c("Brazil","2020-05-11","2020-05-25",NA,
        #"Belgium", "2020-03-13",NA,"2020-04-30",
        "Germany", "2020-03-16","2020-03-16","2020-04-30",
        # "Japan", NA,NA,NA,#*
        # "Sweden", NA,NA,NA,#*
         "UK",NA,"2020-03-26",NA,#*
         "Russia","2020-03-17","2020-03-31",NA,
         "India","2020-03-22","2020-03-25","2020-06-30",
         "France","2020-03-14","2020-03-16","2020-05-11",
         "Italy","2020-03-01","2020-03-09","2020-05-03",
         "Spain",NA,"2020-03-14","2020-05-04",
         "Singapore","2020-04-07",NA,"2020-06-01",
         "S. Africa","2020-03-18","2020-03-23","2020-05-01",
         "Chile","2020-03-26",NA,NA,
         "Colombia",NA,"2020-03-17",NA,
         "Peru",NA,"2020-03-17",NA,
         "Mexico","2020-03-24",NA,NA,
         "Pakistan","2020-03-24",NA,NA,
         "Bangladesh",NA,"2020-03-26","2020-05-30",
         "US","2020-03-21",NA,"2020-04-13",
         "Iran",NA,"2020-03-14","2020-04-20"),ncol=4,byrow=TRUE)) %>% dplyr::rename(Country=V1,partial_lockdown=V2,full_lockdown=V3,partial_opening=V4) 
  
#EU<-list(Brazil="Brazil",Belgium="Belgium",Germany="Germany",Iran="Iran",Italy="Italy",Japan="Japan",Sweden="Sweden",United_Kingdom="UK", Russia="Russia",India="India",South_Africa="S. Africa",Spain="Spain",Poland="Poland",Singapore="Singapore",US="US",Mexico="Mexico",Peru="Peru",Chile="Chile")
  

```

Daily incidences (between `r start_date` and `r end_date`, JHU-CSSE COVID-19 dataset) of several countries are shown: epidemic curve (Fig \@ref(fig:incidencias), transmission curve (fig \@ref(fig:estimations)) and prevalence curve (fig \@ref(fig:cincidence): $CIR_{14}$). Preprocessing parameters include SMA (centered) smoothing, 5 day span, epidemic start with 30 cases/3 days. World Bank data (GDP per capita[@WorldBank]) is used to colour the transmission curves.  

```{r incidencias, fig.cap="\\label{ref:incidencias}COVID-19 incidence in several countries, in logarithmic scale. Weekdays: pink shading.", echo=FALSE,fig.height=9,fig.width=7}
#factor(c(0,1)[Country %in% c("India","Iran","Russia","S. Africa","Brazil")+1])
      
world_results$incidences<-world_results$incidences %>% tidyr::drop_na() 
ggarrange(add_weekdays(ggplot(world_results$incidences %>% dplyr::filter(Incidences>0,dev=="Developed"), aes(x = dates, y = Incidences, group = factor(Country))), mindate=min(world_results$incidences$dates),maxdate=max(world_results$incidences$dates)) +
              #geom_line(aes(y = Incidences,color=Country,linetype=Country),size=1.7,alpha=0.8) +
              #geom_line(aes(y = Incidences),size=0,jli.2,colour="black",linetype=1) +  
              geom_line(aes(y = Incidences,color=Country),size=1.6,alpha=0.68) +
              geom_line(aes(y = Incidences),color="black",size=0.5,alpha=0.6) + 
              #geom_line(aes(y = Incidences,color=Country,linetype=Country),size=1,alpha=0.8) + 
              ggtitle("Developed countries")+ #scale_fill_discrete(name = "Country", labels = EU) +
              labs(x=element_blank(),y="Daily incidence") + my_theme+ggplot2::theme(
                  legend.text=element_text(size=12),
                  axis.title.x=element_blank(),legend.title = element_blank(), legend.position="bottom") + scale_x_date(date_breaks = "4 month",date_labels = "%b") + 
              scale_y_continuous(trans='log10',limits=c(10, max(world_results$incidences %>% dplyr::filter(Incidences>0,dev=="Developed")
                                                            %>% dplyr::select("Incidences"))),labels=scales::comma)+ #xlim(min(incidences$dates),max(incidences$dates)) +
              guides(colour = guide_legend(override.aes = list(alpha = 1))) +facet_grid(vars(dev)) + scale_color_brewer(type="Qual",palette="Paired")+theme_grid+my_theme_13,
          add_weekdays(ggplot(world_results$incidences %>% dplyr::filter(Incidences>0,dev!="Developed"), aes(x = dates, y = Incidences, group = factor(Country))),
                       mindate=min(world_results$incidences$dates),maxdate=max(world_results$incidences$dates))+
              #geom_line(aes(y = Incidences,color=Country,linetype=Country),size=1.7,alpha=0.8) +
              #geom_line(aes(y = Incidences),size=0,jli.2,colour="black",linetype=1) +  
              geom_line(aes(y = Incidences,color=Country),size=1.6,alpha=0.68) +
              geom_line(aes(y = Incidences),color="black",size=0.5,alpha=0.6) +
              #geom_line(aes(y = Incidences,color=Country,linetype=Country),size=1,alpha=0.8) +
              ggtitle("Developing countries")+ #scale_fill_discrete(name = "Country", labels = EU) +
              labs(x= "Date",y="Daily incidence") + my_theme+ggplot2::theme(
                  axis.title.x = element_blank(),legend.title = element_blank(),
                  axis.title.y = element_blank(),legend.position="bottom") + 
              scale_y_continuous(trans='log10',limits=c(10, max(world_results$incidences %>% dplyr::filter(Incidences>0,dev=="Developing")
                                                            %>% dplyr::select("Incidences"))),labels=scales::comma)+
              guides(colour = guide_legend(override.aes = list(alpha = 1))) +facet_grid(vars(dev)) + scale_x_date(date_breaks = "4 month",date_labels = "%b")+ scale_color_brewer(type="Qual",palette="Paired")+theme_grid+my_theme_13,ncol=1)
   
```


```{r estimations, fig.cap="\\label{fig:estimations}$R_t$ estimates for several countries.  Highlighted dates: solid line = full scale measures/lockdown; dashed line = smaller scale measures. Colors: GDP per capita, PPP, in constant 2017 international dollars; from 2019 (2017 for Iran). Higher transmission rates are mostly seen in situations of lower incidences (Spain in July, Chile in May)",echo=FALSE,fig.height=11,fig.width=10}
 
countries_to_plot<-c("Germany","Sweden","UK","Singapore","Japan","Iran","Brazil","Russia","India","S. Africa","Chile","Colombia","Mexico","Peru","Pakistan","Bangladesh","Spain","Italy","France","US")
 
countries_data_to_plot <- world_results$data_to_plot %>% dplyr::filter(Country %in% countries_to_plot) 
 
countries_data_to_plot$Country<-factor(countries_data_to_plot$Country,levels=countries_to_plot,ordered=TRUE)
 
world_bank$Country.Name<-plyr::revalue(world_bank$Country.Name,replace=c("Russian Federation"="Russia",
                                                                         "Iran, Islamic Rep."="Iran",
                                                                         "United States"="US")) 
 
countries_data_to_plot<-countries_data_to_plot %>% merge(world_bank %>% 
  dplyr::select(Country.Name,`X2019`),by.x="Country",by.y="Country.Name",all.x=TRUE,all.y=FALSE) %>% rename(GDP_USD_PC=`X2019`)

countries_data_to_plot<-countries_data_to_plot %>% dplyr::mutate(GDP_USD_PC=ifelse(Country=="Iran",unlist(world_bank %>% filter(Country.Name=="Iran") %>% dplyr::select(X2017)),GDP_USD_PC))

ggplot(countries_data_to_plot[complete.cases(countries_data_to_plot),] %>% dplyr::filter(Method=="Cori, w= 7"), aes(x = date_end, y = as.numeric(`Mean.R.`), group = (Country),color=GDP_USD_PC)) +
    geom_line(aes(y = Mean.R.,color=GDP_USD_PC),size=1.1) +
    geom_ribbon(aes(ymin = `Quantile.0.025.R.`, ymax = `Quantile.0.975.R.`, color=GDP_USD_PC),alpha=0.1) +
    geom_line(aes(y = `Quantile.0.025.R.`,color=GDP_USD_PC),linetype=2,alpha=0.7) +
    geom_line(aes(y = `Quantile.0.975.R.`,color=GDP_USD_PC),linetype=2,alpha=0.7) +
    geom_line(aes(y = Mean.R.,color=GDP_USD_PC),size=1.3,alpha=0.8) +
    geom_line(data=world_results$empiricalR  %>% filter(Country %in% countries_to_plot),aes(y = rho7,x=dates,group=Country),linetype="dashed",color="gold4",size=0.5,alpha=0.6) +
    geom_line(data=(countries_data_to_plot[complete.cases(countries_data_to_plot),] %>% dplyr::filter(Method!="Cori, w= 7",Country %in% countries_to_plot)),aes(y = Mean.R.,x=date_end,group=Country),linetype="dashed",color="darkgreen",size=0.5,alpha=0.6) +
  geom_line(data=(countries_data_to_plot[complete.cases(countries_data_to_plot),] %>% dplyr::filter(Method!="Cori, w= 7",Country %in% countries_to_plot)),aes(y = `Quantile.0.025.R.`,x=date_end,group=Country),size=0.5,linetype="dashed",color="darkgreen",alpha=0.7) +
    geom_line(data=(countries_data_to_plot[complete.cases(countries_data_to_plot),] %>% dplyr::filter(Method!="Cori, w= 7",Country %in% countries_to_plot)),aes(y = `Quantile.0.975.R.`,x=date_end,group=Country),size=0.5,linetype="dashed",color="darkgreen",alpha=0.7) +  
  geom_hline(yintercept=1, linetype="dashed",  color = "black", size=1.05) +
    geom_hline(yintercept=1, linetype="dashed",  color = "black", size=1.05) +
    #ggtitle("Estimated R")+scale_fill_discrete(name = "Country", labels = EU) +
    labs(x= "Date",y="Estimated R") + geom_line(aes(y = Mean.R.),color="black",size=0.1,alpha=0.8) + ylim(c(0.2,3.4)) +
    geom_vline(data=lockdowns,mapping=aes(xintercept=as.Date(partial_lockdown)),linetype="dashed",color="darkred",size=1.05) +
    geom_vline(data=lockdowns,mapping=aes(xintercept=as.Date(full_lockdown)),color="darkred",size=1.05) +
    my_theme +theme_bottom_legend +facet_wrap(facets=vars(Country))+
  scale_x_date(date_breaks = "4 month",date_labels = "%b")+ theme_grid_light +
    scale_color_gradientn(colors=c("red","royalblue",high="darkblue"),values=c(0,0.6,1),trans="log10",labels=scales::comma,na.value="grey70")          
  #scale_colour_brewer(  type = "qual", palette = "Set1", direction = 1, aesthetics = "colour") +  
#estimate_R_plots(estimates,what="R",legend=TRUE)+scale_fill_discrete(name = "Country", labels = EU)
#estimate_R_plots(estimates,what="incid",legend=TRUE)+scale_fill_discrete(name = "Country", labels = EU)
  
```

All countries experienced **exponential transmission** in March 2020, but most developed countries managed to "bend the incidence curve" in April ($R_t<1$), somewhat later in the UK and even later in Sweden and USA. Developing countries had more difficulties reaching decreasing daily incidences, and their $R_t$s stubbornly remained above the control level. Italy and Spain had an abrupt and exponential increase in daily incidences in February/March, and also fast decrease in transmission, maybe due to strict lockdowns. In the reopening phase in June, July and later many countries exhibited $R_t$ surges simultaneous or followed by incidence surges, which in turn preceded cumulative incidence increases. $R_t$ values above but close to 1 did not yield decreasing incidences.   

```{r cincidence, fig.cap="\\label{fig:cincidence}$CIR_{14}$ (/$10^5$ hab), and OI ratio (/$10^6$ hab). $CIR_{14}$ increased later than $R_t$ for most countries: Peru (mid-august), Chile (June), France (August), Spain (August), US (July); and OI ratio declines slightly earlier after a surge",echo=FALSE,fig.height=9,fig.width=8.5}
 
world_results$OA<-rbind(world_results$OA %>% dplyr::filter(distr %in% c("Du"),complete.cases(world_results$OA)) %>% mutate (distr="Ov. Infectivity ratio", 
                                                                                                                             OA_ratio=OA_ratio),
                        (world_results$n_cum %>% dplyr::filter(complete.cases(world_results$n_cum)) %>%
                           mutate(OA_ratio=Ind,distr="14 cum inc ratio",`Overall.Infectivity`=NA)) [,colnames(world_results$OA)]) 
  
countries_to_plot<-c("Germany","Sweden","UK","Singapore","Japan","Iran","Brazil","Russia","India","S. Africa","Chile","Colombia","Mexico","Peru","Pakistan","Bangladesh","Spain","Italy","France","US")

ggplot(world_results$OA %>% dplyr::filter(Country %in% countries_to_plot) %>% dplyr::rename(Indic=distr), aes(x = dates, y = `OA_ratio`, group = (Indic))) +
    geom_line(size=0.6,aes(colour=Indic)) +
    geom_point(size=0.6,aes(colour=Indic)) +
    labs(x= "Date",y="Prevalence estimates") +   
    my_theme_12 +theme_grid_light+theme_bottom_legend +facet_wrap(facets=vars(Country),scales="free")+
  scale_x_date(date_breaks = "4 month",date_labels = "%b")
  #scale_colour_brewer(  type = "qual", palette = "Set1", direction = 1, aesthetics = "colour") + 
#estimate_R_plots(estimates,what="R",legend=TRUE)+scale_fill_discrete(name = "Country", labels = EU)
#estimate_R_plots(estimates,what="incid",legend=TRUE)+scale_fill_discrete(name = "Country", labels = EU)

```

$CIR_{14}$ was one order of magnitude greater than OI ratio, as estimated with EpiEstim, and showed faster decay (consistently with lower infectivity after the first week). 

## Question E. Subnational $Rt$ estimates {#Regional}  

Epidemic curves and transmission curves have been evaluated at subnational level for several countries (Sup. material). The larger and more complex countries are, the more informative and relevant this analysis becomes (USA, SupM/\@ref(USAstates); Spain, SupM/\@ref(Spain)). In smaller subnational entities this analysis is less informative and more homogeneous (Belgium, SupM/\@ref(smoothBelgium), but it can still detect transmission surges (Germany, SupM/\@ref(Germany); Catalonia, SupM/\@ref(CatOutbreaks)). Regional estimates in a developing country (SupM/\@ref(PeruRegions)) showed more variability. 7-day windows $R_t$ estimates are more informative and useful than 3-day windows ones (which contain more short-term fluctuations, often without clinically relevant differences); and different estimates ($R_t$, $R^c_t$, $\rho_7$) conveyed similar information (SupM/\@ref(RENAVE), SupM/\@ref(smoothBelgium), SupM/\@ref(Germany), SupM/\@ref(CatOutbreaks),). 

## Question F. Superspreading events {#superspreadingresults}  

```{r supersddates}
start_date<-as.Date("2020/02/01")
end_date<-as.Date("2020/07/20" )
```

Evaluating the COVID-19 spread in shorter periods requires a careful analysis of the data and its variability. Smoothing the time series or the estimates reduces both the noise and the signal. We have used data from the JHU-CSSE dataset[@JHUdata] and obtained 3-day and 7-day $R_t$ estimates with 3-day smoothing. Transmission curves: Figure \@ref(fig:sn). 

```{r sn,fig.width=11,fig.height=7, fig.cap="\\label{sn}Transmission curves of countries with alleged/possible superspreading events. Our aim is to evaluate whether country-level $R_t$ increased at those time points; and apparently their effect is mostly negligible."}
 


#moderesultssn=list(data_to_plot_modes=data.frame(matrix(NA,nrow=0,ncol=9)),estimates_modes=list())

#moderesults=list(data_to_plot=data.frame(Country=c(),Method=c(),distr=c(),Mode=c(),date_start=c(),date_end=c(),Mean.R.=c(),`Quantile.0.025.R.`=c(),`Quantile.0.975.R.`=c()),estimates_modes=list())

window<-7;

Spain<-fdf_to_inci(ccovid19[(ccovid19$Country.Region=="Spain") & (ccovid19$Province.State=="* All *"),] %>%
                        dplyr::select(-c("Province.State","Country.Region","Lat","Long")) %>% t() %>%
                        as.data.frame() %>% dplyr::rename(Cum=1) %>% tibble::rownames_to_column("dates"),"X%m.%d.%y") %>% 
                        dplyr::filter(dates>=start_date,dates<=end_date)
US<-fdf_to_inci(ccovid19[(ccovid19$Country.Region=="US") & (ccovid19$Province.State=="* All *"),] %>%
                        dplyr::select(-c("Province.State","Country.Region","Lat","Long")) %>% t() %>%
                        as.data.frame() %>% dplyr::rename(Cum=1) %>% tibble::rownames_to_column("dates"),"X%m.%d.%y") %>% 
                        dplyr::filter(dates>=start_date,dates<=end_date)
Italy<-fdf_to_inci(ccovid19[(ccovid19$Country.Region=="Italy") & (ccovid19$Province.State=="* All *"),] %>%
                        dplyr::select(-c("Province.State","Country.Region","Lat","Long")) %>% t() %>%
                        as.data.frame() %>% dplyr::rename(Cum=1) %>% tibble::rownames_to_column("dates"),"X%m.%d.%y") %>% 
                        dplyr::filter(dates>=start_date,dates<=end_date)
Brazil<-fdf_to_inci(ccovid19[(ccovid19$Country.Region=="Brazil") & (ccovid19$Province.State=="* All *"),] %>%
                        dplyr::select(-c("Province.State","Country.Region","Lat","Long")) %>% t() %>%
                        as.data.frame() %>% dplyr::rename(Cum=1) %>% tibble::rownames_to_column("dates"),"X%m.%d.%y") %>% 
                        dplyr::filter(dates>=start_date,dates<=end_date)
France<-fdf_to_inci(ccovid19[(ccovid19$Country.Region=="France") & (ccovid19$Province.State=="* All *"),] %>%
                        dplyr::select(-c("Province.State","Country.Region","Lat","Long")) %>% t() %>%
                        as.data.frame() %>% dplyr::rename(Cum=1) %>% tibble::rownames_to_column("dates"),"X%m.%d.%y") %>% 
                        dplyr::filter(dates>=start_date,dates<=end_date)
Dominicana<-fdf_to_inci(ccovid19[(ccovid19$Country.Region=="Dominican Republic") & (ccovid19$Province.State=="* All *"),] %>%
                        dplyr::select(-c("Province.State","Country.Region","Lat","Long")) %>% t() %>%
                        as.data.frame() %>% dplyr::rename(Cum=1) %>% tibble::rownames_to_column("dates"),"X%m.%d.%y") %>% 
                        dplyr::filter(dates>=start_date,dates<=end_date)


moderesultssn<-comparemodes(countries=list(Italy=incidf_prepro(incidf=Italy,
                      undetected=0.0,  smooth_method="SMA (centered)", smooth_value=3, ignore=15,warnings="",negatives=dbfs)$df,
            Spain=incidf_prepro(incidf=Spain,
                      undetected=0.0, smooth_method="SMA (centered)", smooth_value=3, ignore=15,warnings="",negatives=dbfs)$df,
            US=incidf_prepro(incidf=US,
                      undetected=0.0,  smooth_method="SMA (centered)", smooth_value=3, ignore=15,warnings="",negatives=dbfs)$df,
            France=incidf_prepro(incidf=France,
                      undetected=0.0,  smooth_method="SMA (centered)", smooth_value=3, ignore=15,warnings="",negatives=dbfs)$df,
            `Dominican Republic`=incidf_prepro(incidf=Dominicana,
                      undetected=0.0,  smooth_method="SMA (centered)", smooth_value=3, ignore=15,warnings="",negatives=dbfs)$df),
             mode="SMA,5d", TD=FALSE,windows=c(3,7),with_inci = TRUE, distributions = "Du")


moderesultssn$data_to_plot$Country<-factor(moderesultssn$data_to_plot$Country,levels=(c("Italy","Spain","US","France","Dominican Republic")))

superspread<-data.frame(Country=c("Italy","Spain","Spain","US","US","France","France","Dominican Republic"),date_end=as.Date(c("2020-02-19","2020-02-19","2020-03-08","2020-03-15","2020-05-25","2020-02-21","2020-06-21","2020-07-05")))


ggplot(moderesultssn$data_to_plot %>% dplyr::filter(distr=="Du") %>% tidyr::drop_na(), aes(x = date_end, y = as.numeric(`Mean.R.`),group=as.factor(Method))) +
    geom_line(aes(y = Mean.R.,color=Country),size=1.1) +
    geom_ribbon(aes(ymin = `Quantile.0.025.R.`, ymax = `Quantile.0.975.R.`, fill = "95%CrI",color=Country),alpha=0.1) +
    geom_line(aes(y = `Quantile.0.025.R.`,color=Country),linetype=2,alpha=0.7) +
    geom_line(aes(y = `Quantile.0.975.R.`,color=Country),linetype=2,alpha=0.7) +
    geom_line(aes(y = Mean.R.,color=Country),size=1.3,alpha=0.8) +
    geom_hline(yintercept=1, linetype="dashed",  color = "black", size=1.05) +
    ggtitle("Estimated R") +
    labs(x= "Date",y="Estimated R") + geom_line(aes(y = Mean.R.),color="black",size=0.1,alpha=0.8) + ylim(c(0.2,4.8)) +
    my_theme + 
  scale_colour_brewer(  type = "qual", palette = "Set1", direction = 1, aesthetics = "colour") +
  geom_vline(data = superspread, mapping = aes(xintercept = date_end), size=0.5) +  facet_grid(cols=vars(Country),rows=vars(Method)) + theme(legend.position="bottom")
 
```

February events (Italy, France) took place too early in the epidemic to perform estimations. In Spain the 8 March demonstrations and events took place several weeks later, in the beginning of a period of exponential increase in incidences. A mild increase in $R_t$ is observed around that time, both in daily and weekly estimation windows, but the estimated $R_t$s are unstable and have wide credible intervals. The Spanish regional $R_t$s exhibit some dubious and inconsistent hinges in the decreasing $R_t$ before that date SupM/\@ref(Spain),SupM/\@ref(RENAVE),SupM/\@ref(CatSmooth)).  

In the USA there was a transmission surge in late March, but this event did not take place at a well-defined date. $R_t$ estimates did not noticeably increase either in the riots in late May-July. In state-level estimates (SupM/\@ref(USAstates)) no consistent increase in $R_t$ is seen in early June. In Dominican Republic transmission didn't noticeably increase around the 5th July elections either. A small peak can be observed in France around the Fête de la Musique (2020-06-21), in a period of low incidence and $R_t$ variability. 

Finally, in all the countries many small peaks without any event correlation can be observed.  

## Question G. Outbreaks

As seen in the examples of Germany (SupM/\@ref(Germany)), Catalonia (SupM/\@ref(CatOutbreaks)) and the second wave in many countries (\@ref(dev-nondev-countries), \@ref(Spain)), increases in $R_t$ precede increases in incidence, which in turn precedes prevalence indicators (OI ratio and $CIR_14$). 

# Discussion

## Dataset quality

Daily incidence data is required to perform the estimations, and data quality determines estimates quality. From the data analysis perspective, COVID-19 testing could be regarded a sampling process: Every day a sample of moderate-high pre-test probability cases are tested to obtain an estimate of daily incidence data; the downwards bias in this estimate will be the **untested positive cases** (with pre-test probabilities below testing cutoffs).  A variety of factors can increase these **untested positive cases** or increase the cut-offs required for testing: lack of laboratory capacity, not requiring PCR confirmation for mild cases ([@Dropkin2020],[@MinisterioTransicion]), an increase in low COVID-19 probability cases (due to allergies, common cold, etc.), etc. A lack of adequate contact-tracing infrastructures can also hamper the pre-test probability assessments. Therefore, if COVID-19 time series data is used for modelling, estimation, preventive measures..., it should be preceded by an assessment of this sampling process. In order to compare regions or countries, it has to be assumed that the bias between countries/regions is acceptable. 

COVID-19 underreporting is well-known. In Spain 5.0% and 5.2% of the participants were IgG+ in the two phases of the National COVID-19 Seroprevalence Study[@Seroprev2], while only `r round((213+35)/59568*100,2)` and `r round((267+43)/59165*100,2)` of the participants and `r round(subset(ccovid19,Country.Region=="Spain")[,"X6.3.20"]/46940000*100,2)` of the population on 03-June-2020 had had a PCR+. Underreporting has been assessed by analyzing variations in the positivity percentage, but this indicator might decrease in periods of other flu-like diseases. Another underreporting indicator, the asymptomatic percentage, might be influenced by the mean age of cases (median (IQR) age of COVID-19 cases in Spain: first-wave: 60 (46-79)[@RENAVEdatos], second-wave: 39 (23-55) years[@RENAVEdatos], vs 39 : a small proportion of asymptomatic positives implies cases with low pre-test probability might not be adequately screened. The later is similar between screening studies (Spain: 33%; Iceland: 43%[@Gudbjartsson2020]), but smaller in other datasets (Colombia: `r round((summary(Col$Condition)/nrow(Col))["Asymptomatic"]*100,1)`% [@Colombia]) and varied widely between Spanish regions (30-70%)[@RENAVEdatosOctubre]. The "suspicious" cases reported by Catalonia increased after the initial epidemic peak and might not be a good surrogate for non-reported cases (SupM/\@ref(CatSmooth)). Hospitalizations and deaths could also be considered as surrogates of the real incidence.  

The heterogeneity in definitions, disclosed information or reports impairs comparisons. Number and type of tests, including IgG vs IgM information, should be reported. 

In addition to this, negative incidence values or unexpected peaks can be observed in some temporal series[@Reporte102]. When individualized epidemiological case-reports-derived statistics were available in May/June in Spain[@MinisterioTransicionAnexo][@EPSDatos], with the incidence defined by the symptoms-onset date, data quality increased and unnecessary delays were generally eliminated. Smoothing loses information, but in some datasets it can be considered. 

Most delays could be solved in a similar way to asymptomatic transmission if the distribution of the delay between infection and report is known[@Cori2013]. Linedata and bootstrap methods can be used to obtain a delay distribution, to modify the incidence data[@Abbott2020]. 

## Interventions and surges

According to their objective, public health strategies can be classified in **mitigation**, that aims to slow down the transmission in order to prevent healthcare system collapse ("so that large numbers of people do not become ill at the same time"[@Sweden]), without necessarily stopping epidemic spread, thereby reaching $R(t)$ values close to 1; and **suppression**, which aims to reach $R(t)$<1, including more strict measures and quarantines, and which has been suggested as the recommended strategy for countries which are able to attain it because it would result in less deaths[@ImperialNPI2020]. 

According to their content and epidemic phase, strategies can also be classified (anticipation, early detection, containment, control and mitigation, and elimination). **Containment** can be applied to localized-transmission, it aims to minimize the transmission risk, emphasizing epidemiological investigation, early detection and quarantine of cases and requires significant resources. The appearance of many cases outside the containment areas (disease amplification) renders this approach ineffective[@Parodi2020]; and countries might have to switch to **control and mitigation** strategies that aim to reduce both the socioeconomic disruptions and the health impact[@WHOEpiBook].  

However, the reality of applied strategies is more complex, as it takes into account social, economic and political factors. In Europe, the stay-at-home enforcement yielded the strongest reductions in normalized numbers of contacts in compartmental models[@ECDCModel]. Developed countries have shown better results than developing countries at reducing transmission and bending the curve in March/April, even those that followed a mitigation approach; but they were prone to outbreaks later[@ECDC2jul2020RRA]. Both in developed and developing countries, richer and more densely-populated regions often had earlier and faster transmission starts and higher incidences. 

After epidemic control, the apparition of outbreaks is effectively associated with $R_t$ surges, as seen in the cases of Iran, Spanish regions, German regions, Singapore, etc; although transmission curves should be complimented with incidence curves. The second-wave often exhibited $R_t<1.3$; theoretically, short-term "effective" herd immunity could be achieved if $1-\frac{1}{R_t}$% of the susceptible population is immunized and no reinfections occur (eg. 9% if $R_t=1.1$), this is obtained as an analogy of the relationship between $R_0$ and herd immunity level and could be hypothetically useful. 

Many time-varying transmission indicators attempt to compare current incidence with previous incidence(s), often applying some smoothing to the final estimate. $CIR_{14}$ indicator has the advantage of eliminating the uncertainty of an estimate and providing prevalence information, which is particularly useful for preventive measures; but it has been shown to be a "late" indicator" compared to $R_t$. Both indicators are not directly comparable, but it seems $CIR_{14}$ might overestimate infectiousness risk or prevalence of infective cases when compared to Overall Infectivity ratio. Simplified $R_t$s did not exhibit very large differences when compared to the estimated values. Their bias is probably greater than the $R_t$ and the OI ratio, since they are in fact using a particular fixed distribution of $GT$/$si$. In any case, $R_t$s reflect how fast incidence are expected to varying, but they don't provide incidence information and should be complimented with other indicators. As a disadvantage, $R_t$s exhibited important fluctuations in low-incidence periods. 

## Superspreading events

Superspreading events range between **smaller collective events** involving hundreds-thousands of participants and being amenable to epidemiological investigation that can properly demonstrate epidemiological relationship (Diamond Princess cruise, church assemblies); and **larger collective events** involving tens of thousands of participants which cannot be easily tracked (football matches, massive demonstrations, elections). Considering the fundamental methodological nuances (confirmation bias, weekday bias, correlation vs causation), we couldn't find any conclusive evidence of any impact on transmission curves: they either took place too early in the epidemic, showed questionable and inconstant transmission surges with wide credible intervals, or didn't had any impact on $R_t$s. 

## Study limitations and advantages

In addition to the data limitations, using the $si$ as a surrogate for the $GT$ has a number of potential issues [@Fraser2007], a particular non-negative distribution is assumed [@Lehtinen2020] and the $si$ distributions could be biased (overestimation/underestimation) due to several factors[@Du2020]. Early quarantine of infected individuals is associated with shorter $si$, and this explains observed reductions in the $si$ over time[@Ali2020], due to improved containment policies. Although longer $si$ might slightly widen $R_t$ peaks, marked and relevant differences were not observed between the results obtained with different $GT$ or $si$ distributions; hence supporting the use of $si$ as a practical $GT$ surrogate. Regarding the questions posed previously, we have obtained several examples that could provide an answer to them. We share the application and code so that other researchers can evaluate these issues more in depth. 

Compartmental models can be used to estimate many epidemic parameters [@Herzog2020][@ECDCModel][@Dropkin2020][@Wan2020]; often including the initial $R_0$ and the lower control reproduction number $R_c$ ($R$ after control measures). These showed some variability between different regions but incontrovertibly demonstrated the efficacy of preventive measures[@You2020]. Some early estimates yield higher rates ($R_0 =6.94$, UK, before lockdown)[@Dropkin2020], while others were lower: In Wuhan, February, the average of $R_0$ estimates was 3.28 (median 2.79)[@Liu2020]; in Belgium initial $R_0$ = 3.334 and $R_c$ = 0.713 [@Herzog2020]. Our $R_t$s in the control period are similar to the $R_c$, but our initial $R_t$ seem somewhat unstable, maybe because no clear distinction is made between local and imported cases. Both types of models rely on their own assumptions[@Cori2013]; in time-since infection models no assumptions are made regarding the shape of the transmission curve.  

To conclude, we have provided an application and code that can obtain $R_t$ estimations and perform interactive sensitivity analysis. Nevertheless, the chosen parameters did not have a strong influence on the main information conveyed by the $R_t$ estimates - namely, epidemic control -; therefore $R_t$ can be considered a robust transmission indicator. 

# Supplementary material{#Supp}

## Material and Methods: Application details{#SMM}

The datasets include: [the Center for Systems Science and Engineering at Johns Hopkins University (JHU-CSSE)](https://github.com/CSSEGISandData/COVID-19), [European CDC COVID-19 data (ECDC)](https://data.europa.eu/euodp/en/data/dataset/covid-19-coronavirus-data/resource/eaf23e68-a935-4770-815a-8dd934b2e919), the [New York Times COVID-19 dataset](https://github.com/nytimes/covid-19-data), the Brazil Covid dataset[@CotaCovid19br2020], the official Ministry of Health/Authorities COVID-19 datasets from [Belgium](https://epistat.wiv-isp.be/covid/), [Canada](https://open.canada.ca/data/en/dataset/261c32ab-4cfd-4f81-9dea-7b64065690dc), [Chile](https://github.com/MinCiencia/Datos-COVID19), [Colombia](https://www.datos.gov.co/en/Salud-y-Protecci-n-Social/Casos-positivos-de-COVID-19-en-Colombia/gt2j-8ykr), [Italy](https://github.com/pcm-dpc/COVID-19), [Spain](https://datos.gob.es/es/catalogo/e05070101-evolucion-de-enfermedad-por-el-coronavirus-covid-19) and [Mexico](https://coronavirus.gob.mx/datos/#DownZCSV), [Madrid](https://datos.comunidad.madrid/catalogo/dataset/covid19_tia_zonas_basicas_salud), [Catalonia](https://analisi.transparenciacatalunya.cat/ca/Salut/Registre-de-casos-de-COVID-19-realitzats-a-Catalun/xuwf-dxjd). In many countries, volunteers perform a compilation and curation of daily reports carried out by health authorities; these semiofficial sources of data have been included: [UK (T  White)](https://github.com/tomwhite/covid-19-uk-data), [Germany (J Gehrcke)](https://github.com/jgehrcke/covid-19-germany-gae), [Perú (JM Castagnetto)](https://github.com/jmcastagnetto/covid-19-peru-data), [Portugal (DSSG)](https://github.com/dssg-pt/covid19pt-data). 

Preprocessing options include:

* Increasing daily incidence by a user-defined constant proportion (+0-99%) to account for undetected cases (the **undetected rate**, described as 80-90% in Iceland [@Stock2020], 72% in Italy[@Tuite2020] or 56.5% in Austria [@Bhning2020]).  

* Defining epidemic start date, since calculating the $R$ too early in the epidemic does not provide accurate estimates.  

* Several smoothing methods are available (Lowess, EMA, WMA, SMA...), with their smoothing-span. 

```{r eval=FALSE}
#, which is the traditional way used in time series analysis, or using the future points for averaging, which might be more sensible given the delays introduced by diagnosis and sample processing)
```

* Correcting negative incidences (these reveal an underlying data problem, and they can be eliminated, set to 0, or substracted from previous values (backwards distribution (BDNV), Sup. material, SupM/\@ref(SMM)).  

Negative incidences are invalid by definition and reveal an underlying incidence reporting problem; in some series these values reflect data verification and consolidation, implying that these values are meant to compensate cases counted more than one time. This situation might arise for example if an authority reports the number of positive tests every day and then groups them by individual patients every week; or if an authority aggregates data from several institutions every day without considering whether a positive case was previously tested in two institutions and reported twice. Centralized databases of non-aggregate data could solve these issues. In our application these values can be eliminated or set to 0 before or after smoothing, or they are assumed to be periodic corrections to the case series and a **backwards distribution of negative values before smoothing** (BDNV) is performed. In the BDNV correction, we propose to smooth them with two assumptions: 1) The consolidations $I_{j} , I_{l}$ are negative values at time points $j,l$ of a time series ($I$)); they are meant to correct the data points since the previous correction (or the beginning of the time series, if no previous correction is found). 2) The correction should be applied in a direct proportion to the incidence at each time point. (Therefore, to apply the correction $C_l$ each positive point $I_k$ between the two corrections is divided by the total sum of the points between the corrections, and multiplied by their total sum plus the signed negative correction: $C_{k} = I_k \frac{\sum_{n=j+1}^{k}I_n}{\sum_{n=j+1}^{k-1}I_n}$. The correction point is set to 0.  

Backwards distribution of spurious peaks can also be chosen by the user. A simple peak detector has also been implemented, and it can be applied before smoothing. We arbitrarily define **spurious peaks** as daily incidences greater than 200; and 300% higher than both the two previous and the two following daily incidences; the definition also requires that the two previous and the two following daily incidences are higher than 75. In this case, the corrected spurious peak $C_{k}$ at time $k$ is set to the centered mean average of 5 values, including the original peak value $I_k$, ($C_{k}=\frac{\sum_{n=k-2}^{k+2}I_n}{5}$), where $I_n$ is the daily incidence at day $n$, and the value to distribute backwards is the difference between the peak and the mean, $C_{j} = I_j \frac{\sum_{n=i+1}^{k-1}I_n + (C_{j}-I_j)}{\sum_{n=j+1}^{k-1}I_n}$), where $i$ is the previous spurious peak and all the incidences between both peaks ($i$ and $k$) are corrected: $i < j < k$.

## Question A. Peaks and negative values{#datapeaks}

In the `r nrow(ccovid19[ccovid19$Province.State=="* All *",])` countries in the JHU-CSSE COVID-19 dataset, `r sum(apply(ccovid19[ccovid19$Province.State=="* All *",],MARGIN=1,function(x){return(any(diff(as.numeric(x[6:length(x)]))<0))}))` countries had any negative value (`r paste(ccovid19[ccovid19$Province.State=="* All *",][apply(ccovid19[ccovid19$Province.State=="* All *",], MARGIN=1,function(x){return(any(diff(as.numeric(x[6:length(x)]))<0))}),"Country.Region"],collapse=", ")`) and `r sum(apply(ccovid19[ccovid19$Province.State=="* All *",],MARGIN=1,function(x){i<-diff(as.numeric(x[5:length(x)]));for (j in c(3:(length(i)-2))) {if ((i[j]>200) & ((i[j]/i[j-2])>3) & ((i[j]/i[j-1])>3) & ((i[j]/i[j+2])>3) & ((i[j]/i[j+1])>3)) return (TRUE)} ; return (FALSE) }))` countries had spurious positive peaks (`r  paste(ccovid19[ccovid19$Province.State=="* All *",][apply(ccovid19[ccovid19$Province.State=="* All *",], MARGIN=1,function(x){i<-diff(as.numeric(x[5:length(x)]));for (j in c(3:(length(i)-2))) {if ((i[j]>200) & ((i[j]/i[j-2])>3) & ((i[j]/i[j-1])>3) & ((i[j]/i[j+2])>3) & ((i[j]/i[j+1])>3)) return (TRUE)} ; return (FALSE) }),"Country.Region"],collapse=", ")`). The peak in Spain has been analyzed in SupM/\@ref(spuriouspeaks). In the European CDC dataset `r nrow(unique(ecdc$countriesAndTerritories))`, `r sum(  sapply(unique(ecdc$countriesAndTerritories), function(x){any((ecdc %>% filter(countriesAndTerritories==x) %>% dplyr::select(cases))<0)}))` countries had any negative value (`r paste(unlist(ecdc %>% filter(cases<0) %>% dplyr::mutate(countriesAndTerritories= as.character(countriesAndTerritories))%>% dplyr::select(countriesAndTerritories) %>% distinct()),collapse=", ")`). It is therefore important to start any analysis with the visual exploration of the epidemic curve before and after smoothing, if it is applied.  


## Question A. Dataset quality: Diagnostic delays{#delays}

In Spain the National Epidemiological Vigilance Network (RENAVE) initially in May described the interval between symptoms onset and diagnosis (median = 6 days, interquantile range (IQR) = 3-11 days, cases = 157885) and the interval between symptoms onset and case report (median=6 days, IQR = 3-11 days, cases = 169797 at 21-05-2020)[@RENAVE]. In the official Chilean dataset[@Chile], the mean difference between symptom onset and case notification, as calculated from aggregate data, is `r round(sum(as.numeric(Chiledif[,"Fecha.notificación.confirmada"])* as.numeric(as.Date(Chiledif[,"Categoria.Serie"]))-as.numeric(Chiledif[,"Fecha.inicio.de.sintomas.confirmada"])* as.numeric(as.Date(Chiledif[,"Categoria.Serie"])))/sum(as.numeric(Chiledif[,"Fecha.inicio.de.sintomas.confirmada"])),2)` for reported cases, and `r round(sum(as.numeric(Chiledif[,"Fecha.notificación.2.probable"])* as.numeric(as.Date(Chiledif[,"Categoria.Serie"]))-as.numeric(Chiledif[,"Fecha.inicio.de.sintomas.2.probable"])* as.numeric(as.Date(Chiledif[,"Categoria.Serie"])))/sum(as.numeric(Chiledif[,"Fecha.inicio.de.sintomas.2.probable"])),1)` for likely cases.  

The [Colombia official positive cases dataset](https://www.datos.gov.co/Salud-y-Protecci-n-Social/Casos-positivos-de-COVID-19-en-Colombia/gt2j-8ykr/data)[@Colombia] has been used to assess the diagnostic delays (defined as the difference between symptoms onset and diagnosis) and the reporting delay (defined as the difference between diagnosis and web report). 

`r round(sum(Col$FIS=="Asintomático")/nrow(Col)*100,2)`% of the reported cases as of `r Sys.Date()` were asymptomatic. The diagnostic delay for symptomatic cases has the following characteristics:

* Mean= `r round(mean(Col$Diagnostic.Delay,na.rm=TRUE),3)`

* SD= `r round(mean(Col$Diagnostic.Delay,na.rm=TRUE),3)`

* Percentiles 2.5, 25, 50, 75, 97.5 = `r round(quantile(Col$Diagnostic.Delay,c(0.025,0.25,0.5,0.75,0.975),na.rm=TRUE))`

* Distribution = As shown in figure \@ref(fig:delay-graph)

```{r echo=FALSE,message=FALSE,warning=FALSE}
invisible(gc())
```


```{r delay-graph,fig.width=10.5,fig.height=8,warning=FALSE,error=FALSE,message=FALSE,fig.cap="\\label{fig:delay-graph}Distribution of the diagnostic delay"}
#cbind(data.frame(country="Colombia",Col[,c("FIS","Fecha.diagnostico","fecha.reporte.web")] %>% mutate(Symptoms.onset=as.Date(FIS),Diagnosed=as.Date(Fecha.diagnostico),Reported=as.Date(fecha.reporte.web)) %>% select(c(Symptoms.onset,Diagnosed,Reported))),
#      data.frame(country="Mexico",Mex[,c("FECHA_SINTOMAS","FECHA_DEF","FECHA_ACTUALIZACION")] %>% mutate(Symptoms.onset=s.Date(FECHA_SINTOMAS),Diagnosed=ifelse(FECHA_DEF!="9999-99-99",as.Date(FECHA_DEF),NA),Reported=as.Date(FECHA_ACTUALIZACION)) %>% select(c(Symptoms.onset,Diagnosed,Reported))))
annotate_figure(ggarrange(ggplot(data=Col, aes(x=Diagnostic.Delay)) +geom_density(size=1.5)+xlim(c(0,40))+my_theme_13  + ggplot2::theme(axis.title.x=element_blank(),axis.title.y=element_blank()),
ggplot(data=Col, aes(x=Diagnostic.Delay,color=Ethnicity)) +geom_density(size=1.2)+xlim(c(0,40))+my_theme_13 + ggplot2::theme(axis.title.x=element_blank(),axis.title.y=element_blank()),
ggplot(data=Col, aes(x=Diagnostic.Delay,color=month)) +geom_density(size=1.2)+xlim(c(0,40))+ my_theme_13+ ggplot2::theme(axis.title.x=element_blank(),axis.title.y=element_blank()),
ggplot(data=Col, aes(x=Diagnostic.Delay,color=Condition)) +geom_density(size=1.2)+xlim(c(0,40))+my_theme_13 + ggplot2::theme(axis.title.x=element_blank(),axis.title.y=element_blank())
#,ggplot(data=Col, aes(x=Diagnostic.Delay,color=Departamento.o.Distrito)) +geom_density(size=1.5)+xlim(c(0,40))+ggtitle("Colombia Official COVID-19 data")+my_theme
),
bottom=text_grob("Diagnostic delay",face="bold",size=14),
left=text_grob("Density",face="bold",size=14,rot=90))
DDmodel<-(lm(log(Diagnostic.Delay+1)~Condition+month+Ethnicity,Col))
```

An anomalous peak of mild cases with 13-14 days of diagnostic-delay is observed in July, probably corresponding to data imputation. A linear model has been created with log-transformed diagnostic delay as a dependent variable, and condition, ethnicity and month of diagnosis as predictors (Table: \@ref(tab:ColombiaDD)). This model was chosen even though log-transformed models are less interpretable. With an adjusted $R^2$ of `r summary(DDmodel)$adj.r.squared`, the model performance is poor, but many predictors are significant (table \@ref(tab:ColombiaDD)). 

```{r ColombiaExp}
#mi_kable(list(table(Col$Condition),table(Col$month),table(Col$Ethnicity)),caption="Colombia COVID-19 dataset") 
mi_kable(merge(merge(data.frame(table(Col$Condition)) %>% dplyr::rename(Condition=Var1,`Freq Cond`=Freq),
           data.frame(table(Col$month)) %>% dplyr::rename(month=Var1,`Freq month`=Freq),by=0,all=TRUE),
           data.frame(table(Col$Ethnicity)) %>% dplyr::rename(Ethnicity=Var1,`Freq Ethn`=Freq),by=0,all=TRUE) %>%
    dplyr::select(-1,-2),caption="Colombia COVID-19 summary")

#%>% mi_kable_styling(c("striped", "bordered"))
```

```{r ColombiaDD}
mi_kable(DDmodel,caption="Linear model of diagnostic delay",digits=3,col.names=colnames(summary(DDmodel)$coefficients)) #%>% mi_kable_styling(c("striped", "bordered")) 
```

Mild cases of March with non-specified ethnicity were used as a regression reference values. Diagnostic delay was greater in April and July when compared to March, and greater in patients who died, and greater in black or indigenous patients, but smaller in patients of other ethnicities. However, these differences were mostly small in this dataset. 

The following table summarizes the distribution of the reporting delay.

```{r Col}
Col$Report.Delays<-sapply(as.numeric(Col$Report.Delay),function(Report.Delay){if (is.na(Report.Delay)) NA else if(Report.Delay<0) "<0" else if (Report.Delay==0) "0" else if (Report.Delay<6) "1 to 5" else ">5"})
mi_kable(data.frame(table(factor(Col$Report.Delays, levels=c("<0","0","1 to 5",">5"), ordered=TRUE))) %>% dplyr::rename(`Reporting delay (days)`=Var1,`Number of reports`=Freq)) #%>% mi_kable_styling(c("striped", "bordered"))
```

Differences in diagnostic and reporting infrastructure might explain these results.  

## Question A. Number of tests and rate of positivity{#Tests}

The **rate of positivity**, the number of samples tested positive for COVID-19 in a given location and period, is defined by the WHO as one of the epidemiological criteria of epidemic control: It is met when less than 5% of samples test positive for COVID-19 for at least the previous 2 weeks, but this can only be interpreted when there is thorough surveillance and testing of positive cases[@WHOCriteria]; this criteria has been translated into national protocols[@FrenchGov] and monitoring tools[@TestingInsights]. Herein we use the number of tests and the rate of positivity to assess temporal fluctuations/differences/constraints in the testing process, so the proportion of undetected cases could also vary over time, and the real incidence might particularly be underestimated when the rate of positivity is high. In many areas the daily proportion of positive tests peaked in March 2020: nearly 45% in Castile and León, Spain[@CyLTests]; 17% in Norway; 23% in USA and 10% in April in Canada[@Canada]; in Perú this proportion was kept above 30% between April and August 2020. 

Five datasets have been used to analyze the temporal distribution of testing efforts and, when available, the daily rate of positivity: The Perú data provided by the Peruvian Ministry of Health (MINSA) and compiled by JM Castagnetto [@Castagnetto], the Canadian Government Data on COVID-19 in Canada [@Canada], the USA data from the [John Hopkins COVID-19 Testing Insights Initiative](https://coronavirus.jhu.edu/testing) (CC BY-NC-4.0 license), as reported by USA states[@TestingInsights], dataset containing the [number of COVID-19 tests performed in the region of Cantabria, Spain,](https://www.icane.es/covid19/dashboard/home/home) between `r min(as.Date(Cantabria_tests$Fecha))` and `r max(as.Date(Cantabria_tests$Fecha))` and the dataset containing the [number of COVID-19 tests performed in the region of Castilla y León, Spain](https://datosabiertos.jcyl.es/web/jcyl/set/es/salud/pruebas-coronavirus/1284947954927)[@CyLTests], between `r min(as.Date(as.character(CyL_tests$Date)))` and 18-May-2020 (CC BY-3.0 license). 

The number of COVID-19 PCR and antibodies tests performed each day are graphically reported, and the proportion of positive results is also reported, when available. A smoothing LOESS trendline is added due to considerable variability between days and due to a "weekday-bias" effect particularly noticeable in antibodies tests. Figure \@ref(fig:USA-tests) shows the COVID-19 PCR tests performed in the USA, figure \@ref(fig:PERU-tests) shows the information for Peru, figure \@ref(fig:Canada) shows the tests performed and the positive rate in Canada; with a possible nuance in the former dataset: some USA states might not have clarified what kind of tests they are reporting (PCR or antibodies).  


```{r USA-tests,fig.width=6,fig.height=6,warning=FALSE,error=FALSE,message=FALSE,fig.cap="\\label{fig:USA-tests}PCR tests performed in the USA"}

ggplot(data=US_graph, aes(x=date,y=tests,group=type))+geom_line(aes(colour=type),size=1.25)+facet_grid(rows=vars(val),scales="free_y")+
  ggtitle ("USA performed tests") +scale_y_continuous(labels = scales::comma) +
  geom_smooth(formula="y ~ x",aes(colour=type),method ="loess") +
  ggplot2::theme(axis.title.x = element_text(size = 12), axis.text.x = element_text(size = 12,angle=45),
                axis.title.y = element_text(size = 12), axis.text.y = element_text(size = 13),
                legend.text=element_text(size=13),strip.text = element_text(size = 13))+
  scale_colour_brewer(  type = "qual", palette = "Set1", direction = 1, aesthetics = "colour")

```

```{r PERU-tests,fig.width=7,fig.height=7,warning=FALSE,error=FALSE,message=FALSE,fig.cap="\\label{fig:Peru-tests}COVID-19 tests performed in Peru"}

#Peru_test %>% tidyr::pivot_wider(id_cols=fecha,names_from=c(resultado,tipo_prueba),values_from=personas) %>% mutate (percent_pos_mol=positivo_moleculares/(positivo_moleculares+negativo_moleculares),percent_pos_ser=positivo_serológicaSupM/(positivo_serológicas+negativo_serológicas))


#Peru_test_graph<-rbind(Peru_test %>% dplyr::mutate(val="absolute numbers",resultado=ifelse(resultado=="positivo","positive","negative")),
#      Peru_test_pct %>% dplyr::rename (personas=percent_pos) %>% dplyr::mutate (resultado="positive",val="percentage of positives") %>% dplyr::select (c(fecha, personas,resultado,tipo_prueba,val))) %>% dplyr::rename(type=tipo_prueba,tests = personas,result=resultado) %>% dplyr::mutate(Date=as.Date(fecha)) %>% dplyr::mutate(type=ifelse(type=="moleculares","PCR","Serology"))


add_weekdays(ggplot(data=Peru_test_pct[complete.cases(Peru_test_pct),],   aes(x=Date,y=Tests,group=interaction(Result,type),color=Result)),mindate=min(Peru_test_pct$Date),maxdate=max(Peru_test_pct$Date),border=FALSE)+geom_line(size=0.7)+geom_point(size=0.7)+geom_smooth(formula=y~x,method="loess")+facet_wrap(facets=vars(paste(val,type,sep=" \ ")),scales="free") + ggtitle("Peru: COVID-19 tests")+scale_y_continuous(labels = scales::comma) +
my_theme+theme(legend.position="bottom")+
    scale_colour_brewer(  type = "qual", palette = "Dark2", direction = 1, aesthetics = "colour")


#arrange(ggplot(data=Peru_test_graph, aes(x=Date,y=tests,group=interaction(result,tipo_prueba)))+geom_line(aes(linetype=resultado,color=tipo_prueba),size=1.5)+facet_grid(cols=vars(val)),        ggplot(data=Peru_test_pct, aes(x=as.Date(fecha),y=percent_pos,group=tipo_prueba))+geom_line(aes(color=tipo_prueba),size=1.5),ncol=1)

```

```{r Mex}
mex_neg<-read.csv("https://raw.githubusercontent.com/mariorz/covid19-mx-time-series/master/data/covid19_negatives_mx.csv") %>%
  pivot_longer(-1,values_to ="NegCases",names_to="dates")
mex_susp<-read.csv("https://raw.githubusercontent.com/mariorz/covid19-mx-time-series/master/data/covid19_suspects_mx.csv") %>%
  pivot_longer(-1,values_to ="SuspCases",names_to="dates")
mex_conf<-read.csv("https://raw.githubusercontent.com/mariorz/covid19-mx-time-series/master/data/covid19_confirmed_mx.csv") %>%
  pivot_longer(-1,values_to ="ConfCases",names_to="dates")

Mex <- mex_neg %>% merge(mex_susp,by=c("Estado","dates")) %>% merge(mex_conf,by=c("Estado","dates")) %>%
  mutate(dates=as.Date(dates,"X%d.%m.%Y"))

```


```{r Canada,fig.width=4,fig.height=6,warning=FALSE,error=FALSE,message=FALSE,fig.cap="\\label{fig:Canada}COVID-19 tests performed in Canada"}


(ggplot(data=CanadaGraph %>% dplyr::filter(prname=="Canada"), aes(x=date,y=Tests,colour=Variable)))+geom_line(size=0.6) + geom_point(size=0.7)+ geom_smooth(formula="y ~ x",method ="loess")+ my_theme +
  ggtitle("Canada COVID-19 tests") + scale_colour_brewer(  type = "qual", palette = "Set1", direction = 1, aesthetics = "colour")+ 
    theme(legend.position="bottom",axis.title.x=element_blank(),strip.text.x = element_blank(),strip.background.y=element_blank())+facet_grid(rows=vars(Values),scales="free_y"
    )
    
```


Both the USA and Canada have shown a steady and almost linear increase in testing capacity over time, reaching 600000 and 40000 daily tests respectively at the end of June. Perú also linearly increased their testing capacity over time. In both countries the daily percentages of positive tests have evolved: in the USA the rate of positivity approached 20-25% in April, but then a marked decline was observed and a plateau of ~5% positive tests was reached in May, but in late June, the rate of positives started to increase mildly. In Canada the peak of positives was reached in mid April, around 9%. In Perú the percentage of positive PCRs remained uniform around 30% between April and June, and no information is available for earlier months. 

Figure \@ref(fig:Cantabria) shows the numbers of PCR and antibodies tests performed in this Northern Spanish region. Only the number of performed tests is reported. 

```{r Cantabria,fig.cap="\\label{fig:Cantabria}COVID-19 tests performed in Cantabria, Spain",height=4,width=4}



add_weekdays(ggplot(data=Cantabria_tests, aes(x=Date,y=Tests,group=interaction(Type),colour=Type)),mindate = min(Cantabria_tests$Date),maxdate=max(Cantabria_tests$Date))+geom_line(size=0.9)+ geom_point(aes(shape=Type),size=1.7) + geom_smooth(formula="y ~ x",method ="loess")+ my_theme + scale_colour_brewer(  type = "qual", palette = "Set1", direction = 1, aesthetics = "colour") + ggtitle("Cantabria: Number of daily tests")+
    theme(legend.position="bottom",axis.title.x=element_blank())+lims(y=c(-30,max(Cantabria_tests$Tests))) #+facet_wrap(facets=vars(Type),scales="free") + ggtitle("Perú peformed tests")+scale_y_continuous(labels = scales::comma) +
```

Figure \@ref(fig:CyL1) shows the numbers of PCR and antibodies daily tests performed in Castilla y León, and the percentage of positive results for the whole region.

```{r CyL1,fig.cap="\\label{fig:CyL1}COVID-19 tests performed in Castilla y León, Spain",fig.height=8.5,fig.width=8.5}

add_weekdays(ggplot(data=CyL_tests_ %>% filter(Provincia=="Castilla y León"), aes(x=Date,y=Tests,group=interaction(Type,Result),colour=Result)),mindate = min(CyL_tests_$Date),maxdate=max(CyL_tests_$Date),border=FALSE)+geom_line(size=0.6)+geom_point(size=0.6) + geom_smooth(formula="y ~ x",method ="loess")+ my_theme_13 + scale_colour_brewer(  type = "qual", palette = "Set1", direction = 1, aesthetics = "colour") + ggtitle("Castilla y León: Number of tests and positivity rate")+
    theme(legend.position="bottom",axis.title.x=element_blank(),axis.title.y=element_blank())+lims(y=c(-1,max(CyL_tests_$Tests)))+facet_grid(cols=vars(paste(Val,Type,sep=" / ")),scales = "free")+facet_wrap(facets=vars(paste(Val,Type,sep=" / ")),scales = "free",ncol=2,nrow=2)
```

In both regions of Spain a considerable **weekday-bias** is observed. The PCR testing capacity of Cantabria increased in March and peaked in May. In Castilla y León the rate of positive tests was higher than 40% in March, which could have implications for underestimation of the daily incidence. Both regions showed a stable number of PCR tests performed in May/June, coinciding with epidemic control and reopening phases. 

## Questions A, B. The impact of spurious peaks: Catalonia{#spuriouspeaks}

On the 10th May 2020 Catalonia reported 2721 positive cases respective to the previous day; but only 83 of these cases were new cases[@Reporte102]. (This illustrates a problem that might arise when obtaining daily incidence data from the differences of cumulative total cases: Some health authorities often report cumulative total cases every day; these reports in a particular date might include both the new cases diagnosed that day (incident cases) and cases whose date of symptoms or date of diagnosis is not known). Therefore, some cumulative datasets include a disclaimer against the obtention of incidences by differentiation. An older cumulative version of the Spain Ministry of Health COVID-19 dataset [@MSCdatosold], accessed on 21-May-2020, has been used; it should be noted that newer versions correct this issue (Sup. material, \@ref(RENAVE)). 

Here we assess the impact of the spurious peaks $R_t$ estimates and how different smoothing methods deal with them, including smoothing and proper value replacement. The epidemic curves after preprocessing are shown in figure \@ref(fig:catpeaks) and the transmission curves are shown in figure \@ref(fig:catpeaksr). Standard parameters are used (BDNV), +0% undetected cases). 

```{r catpeaks,eval=TRUE,fig.cap="\\label{fig:catpeaks} Epidemic curves before and after several smoothing methods",echo=FALSE,fig.height=8,fig.width=8} 
Cat_peaks_date<-as.Date("2020-02-25")

cat_corr<-cat<-get_cols(msc_csv_ag,source=MSC_str,province="CT") %>% filter(dates>Cat_peaks_date)
distribute_this<-cat_corr[cat_corr$dates==as.Date("2020-05-10"),"I"]-83
cat_corr[cat_corr$dates==as.Date("2020-05-10"),"I"]<-83
values_before_correction<-cat_corr[cat_corr$dates<as.Date("2020-05-09"),"I"]
cat_corr[cat_corr$dates<as.Date("2020-05-09"),"I"]<-round(values_before_correction*sum(values_before_correction)/sum(values_before_correction,distribute_this))
# No smoothing, no augmentation
moderesultspeak<-comparemodes(list(Catalonia_Original=incidf_prepro(incidf=cat,
                      undetected=0.0, smooth_method="Lowess", smooth_value=0, ignore=15,warnings="",negatives=dbfs)$df,
             Lowess_soft=incidf_prepro(incidf=cat,
                      undetected=0.0, smooth_method="Lowess", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df,
             Lowess_strong=incidf_prepro(incidf=cat,
                      undetected=0.0,  smooth_method="Lowess", smooth_value=7, ignore=15,warnings="",negatives=dbfs)$df,
             SMA_soft=incidf_prepro(incidf=cat,
                      undetected=0.0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df,
             SMA_strong=incidf_prepro(incidf=cat,
                      undetected=0.0, smooth_method="SMA (centered)", smooth_value=7, ignore=15,warnings="",negatives=dbfs)$df,
             Peak_properly_corrected=incidf_prepro(incidf=cat_corr,
                      undetected=0.0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df
             ),mode="Peak elimination",TD=FALSE,distributions=c("Du"),with_inci = TRUE)

moderesultspeak$data_to_plot <- moderesultspeak$data_to_plot %>% rename(Settings=Country)
moderesultspeak$incidences <- moderesultspeak$incidences %>% mutate(Settings=factor(Country,levels=c("Catalonia_Original","Lowess_soft","Lowess_strong","SMA_soft","SMA_strong","Peak_properly_corrected"),ordered=TRUE))

add_weekdays(ggplot(moderesultspeak$incidences[moderesultspeak$incidences$Incidences>0 & complete.cases(moderesultspeak$incidences),], aes(x = dates, y = Incidences)), mindate=min(moderesultspeak$incidences$dates),maxdate=max(moderesultspeak$incidences$dates)) +
  geom_line(aes(y = Incidences),size=1.3,alpha=0.8) + geom_point()+
    #geom_line(aes(y = Incidences,color=Country,linetype=Country),size=1,alpha=0.8) +
    ggtitle("The impact of spurious peaks (Catalonia, Spain)")+ #scale_fill_discrete(name = "Country", labels = EU) +
    labs(x=element_blank(),y="Daily incidence") + my_theme + ggplot2::theme(
                axis.title.x=element_blank(), strip.text =element_text(size=13))+
  facet_wrap(facets=vars(Settings))

```

Compared to the SMA, the Lowess smoothing is more tolerant with peaks (and in some settings might not correct them); and the SMA is more influenced by these peaks. This reflects the different philosophy of these methods (mean averaging vs polynomial regression). A second-pass SMA might be useful in some particular cases. 

```{r catpeaksr,fig.width=8,fig.height=8,eval=TRUE,fig.cap="\\label{fig:catpeaksr} Transmission curves before and after several smoothing methods",echo=FALSE} 

ggplot(moderesultspeak$data_to_plot, aes(x = date_end, y = as.numeric(`Mean.R.`),group=as.factor(Settings))) +
    geom_line(aes(y = Mean.R.),size=1.1) +
    geom_ribbon(aes(ymin = `Quantile.0.025.R.`, ymax = `Quantile.0.975.R.`),alpha=0.1) +
    geom_line(aes(y = `Quantile.0.025.R.`),linetype=2,alpha=0.7) +
    geom_line(aes(y = `Quantile.0.975.R.`),linetype=2,alpha=0.7) +
    geom_line(aes(y = Mean.R.),size=1.3,alpha=0.8) +
    geom_hline(yintercept=1, linetype="dashed",  color = "black", size=1.05) +
    ggtitle("The impact of spurious peaks (Catalonia, Spain)") +
    labs(x= "Date",y="Estimated R") + geom_line(aes(y = Mean.R.),color="black",size=0.1,alpha=0.8) + ylim(c(0.2,4.8)) +
    my_theme +
  scale_colour_brewer(  type = "qual", palette = "Set1", direction = 1, aesthetics = "colour") +
  facet_wrap(vars(Settings))

```

The spurious peak causes clinically-relevant spurious $R_t$ estimates if it is not properly corrected. Lowess correction seemed a reasonable method when dealing with these peaks, but proper visually-guided tuning of smoother span is recommended, as small spans could left some peaks. When the SMA correction was applied, the effect is more predictable, but spurious $R_t$ estimates were obtained. 

## Question B. Serial interval distributions{#siss}

Deriving the reproduction number from incidence data requires knowledge of the $GT$ or $si$; several distributions are available in the application:  

* Single $si$ distributions:  

  - Log-normally distributed with dataset derived point-estimates (obtained via Markov-chains Montecarlo, MCMC): Nishiura et al, Du et al, Zhao et al, Ali et al. Null or negative values are excluded due to EpiEstim package requirements. 

  - Gamma-distributed, author estimates: Li et al(early in the pandemic), Liu et al.  

* Single $GT$ distributions: Gamma-distributed, author estimates: Ganyani et al, Singapore or Tianjin.  

* Multiple MCMC-derived $si$ distributions: Lognormally-distributed, and obtained via MCMC from the authors datasets: Nishiura et al, Du et al, Zhao et al, Ali et al.   

* Multiple bootstrapping-derived $GT$ distributions: Gamma-distributed: Ganyani et al (Singapore or Tianjin). 

* Multiple bootstrapping-derived $si$ distributions: Truncated-normally distributed, with minimum at 0: Ali et al, either early-quarantined (two lower quartiles of isolation delay) or late-quarantined (the two higher quartiles) [@Ali2020]. 

In order to perform the bootstrapping the reported distribution-defining parameters with their credible interval ([@Ganyani2020],[@Ali2020]) are used. 1000 samples of distribution parameters are obtained from a modified-PERT distribution using the estimate as mode, credible interval limits as distribution limits and shape = 4; to obtain multiple distributions. These distributions are detailed in SupM/\@ref(siss). 

The original $si$ **datasets** from Nishiura [@Nishiura2020], from Du [@Du2020], from Zhao [@Zhao2020] and from Ali [@Ali2020] were obtained; providing both exact and censored $si$. Cases with non-positive $si$ were excluded from the last two datasets, due to EpiEstim package requirements. The datasets can also be used to apply a Markov Chain MonteCarlo method to obtain point-estimates of the parameters of the lognormal distribution of the $si$[@Thompson2019]; a lognormal distribution was chosen since the original authors reported it provided the best fit. (The lognormal distribution can be defined as the distribution of the variable $X = e^{\mu + \sigma Z}$, where $Z$ is a standard normal variable, and $\mu$ and $\sigma$ are two real numbers, which are the mean and standard deviation of the logarithm of $X$. The implementation in the R package coarseDataTools[@Reich2009] was used (Metropolis-Hastings algorithm, with 12000 iterations, burn-in of 2000 and thinning = 1/10) and convergence checks were perfomed with the Gelman-Rubin diagnostic)). Thus we obtained both point estimates of the $si$ distribution; and multiple $si$ distributions. 

When no dataset was available, we incorporated the point estimates as single $si$ or $GT$ distribution, and performed bootstrapping with the confidence or credible intervals were available. We used the point-estimates of the $GT$ reported by Ganyani, obtained with data from clusters in Singapore, and in Tianjin. We took the mean and standard deviation estimates and their credible interval, and used them as the defining parameters of a triangular distribution (where the estimate is the mode and the credible intervals are the limits). From this we randomly sampled 5000 means and standard deviations of the $si$, and calculated 5000 gamma distributions of the $si$. Thus we have the original point estimates of the GT distribution; and multiple GT distributions. The same procedure was applied to the Ali[@Ali2020], early isolation and late isolation $si$ descriptions (truncated normal distributions, starting at 0). 

The available distributions are shown in figure \@ref(fig:siss). The point estimates for the $si$ or $GT$, obtained either via MCMC (Ali et al, Du et al, Nishiura et al, Zhao et al) or reported by their authors (Ganyani et al, Li et al, Liu et al, Ali et al (early isolation), Ali et al (late isolation)) are shown in  \@ref(tab:sis2), with 95% credible intervals, along relevant with percentiles. For the Log-normal distribution, $mu$ (Mu) and $sigma$ (Sigma) are reported; for the Gamma  or truncated normal distribution, mean and standard deviation are reported. 

```{r siss, fig.cap="\\label{fig:siss} Distributions of the of the $si$ and $GT$. Pt: Point distributions. MCMC: Obtained via MCMC. BT: Obtained via bootstrapping.",fig.width=10,fig.height=9,warning=FALSE,error=FALSE,message=FALSE}

prueba<-fdf_to_inci(ccovid19[(ccovid19$Country.Region=="Russia") & (ccovid19$Province.State=="* All *"),] %>%
                        dplyr::select(-c("Province.State","Country.Region","Lat","Long")) %>% t() %>%
                        as.data.frame() %>% dplyr::rename(Cum=1) %>% tibble::rownames_to_column("dates"),"X%m.%d.%y")
prueba<-prueba[(prueba$dates>=as.Date("2020-03-13")) & (prueba$dates<=as.Date("2020-03-22")),c("dates","I")]

grid.arrange(
  plot(calculate_R(incidf=prueba,prepro = FALSE, distribution="Du",return_object=TRUE),what="SI",options_SI=list(transp=0.07))+ggtitle("Du. MCMC"),
plot(calculate_R(incidf=prueba,prepro = FALSE, distribution="Du Point",return_object=TRUE),what="SI",options_SI=list(size=1.2,transp=0.9))+ggtitle("Du. Pt. MCMC"),
plot(calculate_R(incidf=prueba,prepro = FALSE, distribution="Nishiura",return_object=TRUE),what="SI",options_SI=list(transp=0.07))+ggtitle("Nishiura. MCMC"),
plot(calculate_R(incidf=prueba,prepro = FALSE, distribution="Nishiura Pt",return_object=TRUE),what="SI",options_SI=list(size=1,transp=0.9))+ggtitle("Nishiura. Pt. MCMC"),
plot(calculate_R(incidf=prueba,prepro = FALSE, distribution="Zhao",return_object=TRUE),what="SI",options_SI=list(transp=0.07))+ggtitle("Zhao. MCMC"),
plot(calculate_R(incidf=prueba,prepro = FALSE, distribution="Zhao Pt",return_object=TRUE),what="SI",options_SI=list(size=1.2,transp=0.9))+ggtitle("Zhao. Pt. MCMC"),
plot(calculate_R(incidf=prueba,prepro = FALSE, distribution="Li",return_object=TRUE),what="SI",options_SI=list(size=1.2,transp=0.9))+ggtitle("Li. Pt."),
plot(calculate_R(incidf=prueba,prepro = FALSE, distribution="Liu",return_object=TRUE),what="SI",options_SI=list(size=1.2,transp=0.9))+ggtitle("Liu. Pt."),
plot(calculate_R(incidf=prueba,prepro = FALSE, distribution="Ali",return_object=TRUE),what="SI",options_SI=list(transp=0.07))+ggtitle("Ali. MCMC"),
plot(calculate_R(incidf=prueba,prepro = FALSE, distribution="Ali Pt",return_object=TRUE),what="SI",options_SI=list(size=1.2,transp=0.9))+ggtitle("Ali. Pt. MCMC"),
plot(calculate_R(incidf=prueba,prepro = FALSE, distribution="Ali early",return_object=TRUE),what="SI",options_SI=list(transp=0.07))+ggtitle("Ali. Early. Boot"),
plot(calculate_R(incidf=prueba,prepro = FALSE, distribution="Ali early Pt",return_object=TRUE),what="SI",options_SI=list(size=1,transp=0.9))+ggtitle("Ali. Early. Pt."),
plot(calculate_R(incidf=prueba,prepro = FALSE, distribution="Ali late",return_object=TRUE),what="SI",options_SI=list(transp=0.07))+ggtitle("Ali. Late. Boot"),
plot(calculate_R(incidf=prueba,prepro = FALSE, distribution="Ali late Pt",return_object=TRUE),what="SI",options_SI=list(size=1.2,transp=0.9))+ggtitle("Ali. Late. Pt."),
plot(calculate_R(incidf=prueba,prepro = FALSE, distribution="Ganyani Singapore",return_object=TRUE),what="SI",options_SI=list(transp=0.07))+ggtitle("Ganyani Singapore. Bt"),
plot(calculate_R(incidf=prueba,prepro = FALSE, distribution="Ganyani Singapore Pt",return_object=TRUE),what="SI",options_SI=list(size=1.2,transp=0.9))+ggtitle("Ganyani Singapore Pt"),
plot(calculate_R(incidf=prueba,prepro = FALSE, distribution="Ganyani Tianjin",return_object=TRUE),what="SI",options_SI=list(transp=0.07))+ggtitle("Ganyani Tianjin. Bt"),
plot(calculate_R(incidf=prueba,prepro = FALSE, distribution="Ganyani Tianjin Pt",return_object=TRUE),what="SI",options_SI=list(size=1.2,transp=0.9))+ggtitle("Ganyani Tianjin Pt"),ncol=4,nrow=5)


```

```{r plotcurvas,eval=FALSE}
plot(dgamma(seq(0,30),shape=liu_m$kappa,scale=liu_m$theta),type="b")
lines(dgamma(seq(0,30),shape=li_m$kappa,scale=li_m$theta),type="b")
```


```{r sis2}
sis<-data.frame() %>% mutate(N=NA,place=NA,distribution=NA,mu=NA,mu_ci_low=NA,mu_ci_high=NA,sd=NA,sd_ci_low=NA,sd_ci_high=NA,my_median=NA,my_mode=NA,p5=NA,p95=NA)
sis["Du (si), MCMC",]<-c(nrow(SI_fit_clever_X@data),"China","Lognormal",c(t(SI_fit_clever_X@ests[c("meanlog","sdlog"),])),SI_fit_clever_X@ests["p50","est"],round(exp(SI_fit_clever_X@ests["meanlog","est"]-SI_fit_clever_X@ests["sdlog","est"]^2),3),SI_fit_clever_X@ests["p5","est"],SI_fit_clever_X@ests["p95","est"])
sis["Nishiura (si), MCMC",]<-c(nrow(SI_fit_clever_Nishiura@data),"Articles and reports","Lognormal",c(t(SI_fit_clever_Nishiura@ests[c("meanlog","sdlog"),])),SI_fit_clever_Nishiura@ests["p50","est"],round(exp(SI_fit_clever_Nishiura@ests["meanlog","est"]-SI_fit_clever_Nishiura@ests["sdlog","est"]^2),3),SI_fit_clever_Nishiura@ests["p5","est"],SI_fit_clever_Nishiura@ests["p95","est"])
sis["Zhao (si), MCMC",]<-c(nrow(SI_fit_clever_Zhao@data),"Hong Kong (GovHK)","Lognormal",c(t(SI_fit_clever_Zhao@ests[c("meanlog","sdlog"),])), SI_fit_clever_Zhao@ests["p50","est"],round(exp(SI_fit_clever_Zhao@ests["meanlog","est"]-SI_fit_clever_Zhao@ests["sdlog","est"]^2),3),SI_fit_clever_Zhao@ests["p5","est"],SI_fit_clever_Zhao@ests["p95","est"])
sis["Ali (si), MCMC",]<-c(677,"China","Lognormal",c(t(SI_fit_clever_Ali@ests[c("meanlog","sdlog"),])), SI_fit_clever_Ali@ests["p50","est"],round(exp(SI_fit_clever_Ali@ests["meanlog","est"]-SI_fit_clever_Ali@ests["sdlog","est"]^2),3),SI_fit_clever_Ali@ests["p5","est"],SI_fit_clever_Ali@ests["p95","est"])
sis["Ganyani (GT) S",]<-c(54,"Singa-pore","Gamma",5.20,3.78,6.78,1.72,0.91,3.73,qgamma(p=0.5,shape=sing_m$kappa,scale=sing_m$theta) ,if(sing_m$kappa>1) (sing_m$kappa-1)*(sing_m$theta) else NA,qgamma(p=0.05,shape=sing_m$kappa,scale=sing_m$theta), qgamma(p=0.95,shape=sing_m$kappa,scale=sing_m$theta))
sis["Ali (si), early isolation",]<-c(339,"China","Trunc.normal",ali_early_isolation$mean,ali_early_isolation$mean_ci_low,ali_early_isolation$mean_ci_high, ali_early_isolation$sd, ali_early_isolation$sd_ci_low, ali_early_isolation$sd_ci_high, qtruncnorm(p=0.5,a=0,mean=ali_early_isolation$mean,sd=ali_early_isolation$sd) , ali_early_isolation$mean, qtruncnorm(p=0.05,a=0,mean=ali_early_isolation$mean,sd=ali_early_isolation$sd), qtruncnorm(p=0.95,a=0,mean=ali_early_isolation$mean,sd=ali_early_isolation$sd))
sis["Ali (si), late isolation",]<-c(339,"China","Trunc.normal",ali_late_isolation$mean,ali_late_isolation$mean_ci_low,ali_late_isolation$mean_ci_high, ali_late_isolation$sd, ali_late_isolation$sd_ci_low, ali_late_isolation$sd_ci_high,qtruncnorm(p=0.5,a=0,mean=ali_late_isolation$mean,sd=ali_late_isolation$sd) , ali_late_isolation$mean, qtruncnorm(p=0.05,a=0,mean=ali_late_isolation$mean,sd=ali_late_isolation$sd), qtruncnorm(p=0.95,a=0,mean=ali_late_isolation$mean,sd=ali_late_isolation$sd))


sis<-sis %>%tibble::rownames_to_column("Dataset")%>% mutate (mu=as.numeric(mu),mu_ci_high=as.numeric(mu_ci_high),mu_ci_low=as.numeric(mu_ci_low),
                     sd=as.numeric(sd),sd_ci_high=as.numeric(sd_ci_high),sd_ci_low=as.numeric(sd_ci_low),my_median=round(as.numeric(my_median),3),my_mode=round(as.numeric(my_mode),3),p5=round(as.numeric(p5),3),p95=round(as.numeric(p95),3)) %>%
  mutate (`mu_ci_text`=paste(ifelse(distribution=="Gamma","Mean= ","Mu= "), round(mu,3)," (",round(mu_ci_low,3),", ",round(mu_ci_high,3),")",sep=""), `sd_ci_text`=paste(ifelse(distribution=="Gamma","SD= ","Sigma= ") ,round(sd,3)," (",round(sd_ci_low,3),", ",round(sd_ci_high,3),")",sep=""))
flextable(sis  %>% dplyr::select (Dataset,N,place,distribution,mu_ci_text,sd_ci_text,my_median,my_mode,p5,p95)) %>% set_header_labels(Dataset="Source",N="Number of cases",place="Location",distribution="Distri-bution",mu_ci_text="Mu/ Mean",sd_ci_text="Sigma/ SD",my_median="Median",my_mode="Mode",p5="Percen-tile 5",p95="Percen-tile 95") %>% add_header_lines("si and GT distributions") %>%
  add_footer_lines("Source of the information here shown: Point estimates of mu and sigma are obtained via MCMC (10000 iterations, burnin=2000, convergence tested via Gelman-Rubin diagnostic) from Du, Nishiura, Zhao and Ali; and quantiles and mode are calculated from the estimates. For the distributions obtained from Ganyani, Li, Liu, Ali (early isolation cases) and Ali (late isolation cases) the estimates are obtained from the original paper, and quantiles are calculated from the estimates.") #%>% mi_kable_styling(c("striped", "bordered"))
```

## Question B. Preprocessing options{#preproSpain}

```{r prep-dates}

ppStart<-as.Date("2020-03-10")
ppEnd<-as.Date("2021-06-10"  )
``` 

The impact of the different preprocessing options on the transmission curves is evaluated in the figure \@ref(fig:prepro). (Parameters: JHU-CSSE dataset, dates between `r strftime(ppStart,"%d-%B-%Y")` and `r strftime(ppEnd,"%d-%B-%Y")`, different smoothing parameters and spans). 

```{r prepro,fig.width=9,fig.height=8,fig.cap="\\label{fig:prepro} Sensitivity analysis for different preprocessing parameters"}
 
#ppStart<-as.Date("2020-03-05")
#ppEnd<-as.Date("2020-06-15")

# No smoothing, no augmentation 
moderesultspre<-comparemodes(list(Spain=incidf_prepro(incidf=Spain %>% dplyr::filter(dates>=ppStart,dates<=ppEnd),
                      undetected=0.0, smooth_method="EMA (future)", smooth_value=0, ignore=15,warnings="",negatives=dbfs)$df,
             US=incidf_prepro(incidf=US %>% dplyr::filter(dates>=ppStart,dates<=ppEnd),
                      undetected=0.0,  smooth_method="EMA (future)", smooth_value=0, ignore=15,warnings="",negatives=dbfs)$df,
             Brazil=incidf_prepro(incidf=Brazil %>% dplyr::filter(dates>=ppStart,dates<=ppEnd),
                      undetected=0.0, smooth_method="EMA (future)", smooth_value=0, ignore=15,warnings="",negatives=dbfs)$df),mode="0% undetected, no smoothing",TD=FALSE,distributions=c("Du"))

# No augmentation, SMA centered
moderesultspre<-comparemodes(list(Spain=incidf_prepro(incidf=Spain,
                      undetected=0.0, smooth_method="SMA (centered)", smooth_value=3, ignore=15,warnings="",negatives=dbfs)$df,
             US=incidf_prepro(incidf=US,
                      undetected=0.0,  smooth_method="SMA (centered)", smooth_value=3, ignore=15,warnings="",negatives=dbfs)$df,
             Brazil=incidf_prepro(incidf=Brazil,
                      undetected=0.0,  smooth_method="SMA (centered)", smooth_value=3, ignore=15,warnings="",negatives=dbfs)$df),mode="0% undetected, SMA (centered) soft", TD=FALSE,moderesults=moderesultspre,distributions=c("Du"))

# No augmentation, SMA centered
moderesultspre<-comparemodes(list(Spain=incidf_prepro(incidf=Spain,
                      undetected=0.0, smooth_method="SMA (centered)", smooth_value=7, ignore=15,warnings="",negatives=dbfs)$df,
             US=incidf_prepro(incidf=US,
                      undetected=0.0,  smooth_method="SMA (centered)", smooth_value=7, ignore=15,warnings="",negatives=dbfs)$df,
             Brazil=incidf_prepro(incidf=Brazil,
                      undetected=0.0,  smooth_method="SMA (centered)", smooth_value=7, ignore=15,warnings="",negatives=dbfs)$df),mode="0% undetected, SMA (centered) hard", TD=FALSE,moderesults=moderesultspre,distributions=c("Du"))

# No augmentation, EMA (future)
moderesultspre<-comparemodes(list(Spain=incidf_prepro(incidf=Spain,
                      undetected=0.0, smooth_method="EMA (future)", smooth_value=3, ignore=15,warnings="",negatives=dbfs)$df,
             US=incidf_prepro(incidf=US,
                      undetected=0.0,  smooth_method="EMA (future)", smooth_value=3, ignore=15,warnings="",negatives=dbfs)$df,
             Brazil=incidf_prepro(incidf=Brazil,
                      undetected=0.0,  smooth_method="EMA (future)", smooth_value=3, ignore=15,warnings="",negatives=dbfs)$df),mode="0% undetected, EMA (future) soft", TD=FALSE,moderesults=moderesultspre,distributions=c("Du"))

# No augmentation, EMA (future)
moderesultspre<-comparemodes(list(Spain=incidf_prepro(incidf=Spain,
                      undetected=0.0, smooth_method="EMA (future)", smooth_value=6, ignore=15,warnings="",negatives=dbfs)$df,
             US=incidf_prepro(incidf=US,
                      undetected=0.0,  smooth_method="EMA (future)", smooth_value=6, ignore=15,warnings="",negatives=dbfs)$df,
             Brazil=incidf_prepro(incidf=Brazil,
                      undetected=0.0,  smooth_method="EMA (future)", smooth_value=6, ignore=15,warnings="",negatives=dbfs)$df),mode="0% undetected, EMA (future) hard", TD=FALSE,moderesults=moderesultspre,distributions=c("Du"))

# Smoothing, augmentation
moderesultspre<-comparemodes(list(Spain=incidf_prepro(incidf=Spain,
                      undetected=0.4, smooth_method="EMA (future)", smooth_value=0, ignore=15*1/(1-0.4),warnings="",negatives=dbfs)$df,
             US=incidf_prepro(incidf=US,
                      undetected=0.4,  smooth_method="EMA (future)", smooth_value=0, ignore=15*1/(1-0.4),warnings="",negatives=dbfs)$df,
             Brazil=incidf_prepro(incidf=Brazil,
                      undetected=0.4,  smooth_method="EMA (future)", smooth_value=0, ignore=15*1/(1-0.4),warnings="",negatives=dbfs)$df),mode="+40% undetected, no smoothing", TD=FALSE,moderesults=moderesultspre,distributions=c("Du"))

# Smoothing, augmentation
moderesultspre<-comparemodes(list(Spain=incidf_prepro(incidf=Spain,
                      undetected=0.4, smooth_method="EMA (future)", smooth_value=3, ignore=15*1/(1-0.4),warnings="",negatives=dbfs)$df,
             US=incidf_prepro(incidf=US,
                      undetected=0.4,  smooth_method="EMA (future)", smooth_value=3, ignore=15*1/(1-0.4),warnings="",negatives=dbfs)$df,
             Brazil=incidf_prepro(incidf=Brazil,
                      undetected=0.4,  smooth_method="EMA (future)", smooth_value=3, ignore=15*1/(1-0.4),warnings="",negatives=dbfs)$df),mode="+40% undetected, EMA (future) soft", TD=FALSE,moderesults=moderesultspre,distributions=c("Du"))

# Smoothing, augmentation
moderesultspre<-comparemodes(list(Spain=incidf_prepro(incidf=Spain,
                      undetected=0.4, smooth_method="EMA (future)", smooth_value=6, ignore=15*1/(1-0.4),warnings="",negatives=dbfs)$df,
             US=incidf_prepro(incidf=US,
                      undetected=0.4,  smooth_method="EMA (future)", smooth_value=6, ignore=15*1/(1-0.4),warnings="",negatives=dbfs)$df,
             Brazil=incidf_prepro(incidf=Brazil,
                      undetected=0.4,  smooth_method="EMA (future)", smooth_value=6, ignore=15*1/(1-0.4),warnings="",negatives=dbfs)$df),mode="+40% undetected, EMA (future) hard", TD=FALSE,moderesults=moderesultspre,distributions=c("Du"))


#
moderesultspre<-comparemodes(list(Spain=incidf_prepro(incidf=Spain,
                      undetected=0.4, smooth_method="EMA (past)", smooth_value=5, ignore=15*1/(1-0.4),warnings="",negatives=dbfs)$df,
             US=incidf_prepro(incidf=US,
                      undetected=0.4,  smooth_method="EMA (past)", smooth_value=5, ignore=15*1/(1-0.4),warnings="",negatives=dbfs)$df,
             Brazil=incidf_prepro(incidf=Brazil,
                      undetected=0.4,  smooth_method="EMA (past)", smooth_value=5, ignore=15*1/(1-0.4),warnings="",negatives=dbfs)$df),mode="+40% undetected, EMA (past)", TD=FALSE,moderesults=moderesultspre,distributions=c("Du"))


# Smoothing, augmentation
moderesultspre<-comparemodes(list(Spain=incidf_prepro(incidf=Spain,
                      undetected=0.4, smooth_method="Lowess", smooth_value=7, ignore=15*1/(1-0.4),warnings="",negatives=dbfs)$df,
             US=incidf_prepro(incidf=US,
                      undetected=0.4,  smooth_method="Lowess", smooth_value=7, ignore=15*1/(1-0.4),warnings="",negatives=dbfs)$df,
             Brazil=incidf_prepro(incidf=Brazil,
                      undetected=0.4,  smooth_method="Lowess", smooth_value=7, ignore=15*1/(1-0.4),warnings="",negatives=dbfs)$df),mode="+40% undetected, Lowess", TD=FALSE,moderesults=moderesultspre,distributions=c("Du"))

# Smoothing, augmentation
#moderesultspre<-comparemodes(list(Spain=incidf_prepro(incidf=Spain,
#                      undetected=0.4, smooth_method="Lowess", smooth_value=9, ignore=15,warnings="",negatives=dbfs)$df,
#             US=incidf_prepro(incidf=US,
#                      undetected=0.4,  smooth_method="Lowess", smooth_value=9, ignore=15,warnings="",negatives=dbfs)$df,
#             Brazil=incidf_prepro(incidf=Brazil,
#                      undetected=0.4,  smooth_method="Lowess", smooth_value=9, ignore=15,warnings="",negatives=dbfs)$df),mode="+40% undetected, Lowess strong", TD=FALSE,moderesults=moderesultspre,distributions=c("Du"))

# Smoothing, augmentation
moderesultspre<-comparemodes(list(Spain=incidf_prepro(incidf=Spain,
                      undetected=0.95, smooth_method="Lowess", smooth_value=7, ignore=15*1/(1-0.95),warnings="",negatives=dbfs)$df,
             US=incidf_prepro(incidf=US,
                      undetected=0.95,  smooth_method="Lowess", smooth_value=7, ignore=15*1/(1-0.95),warnings="",negatives=dbfs)$df,
             Brazil=incidf_prepro(incidf=Brazil,
                      undetected=0.95,  smooth_method="Lowess", smooth_value=7, ignore=15*1/(1-0.95),warnings="",negatives=dbfs)$df),mode="+95% undetected, Lowess", TD=FALSE,moderesults=moderesultspre,distributions=c("Du"))

ggplot(moderesultspre$data_to_plot %>% dplyr::filter(distr=="Du"), aes(x = date_end, y = as.numeric(`Mean.R.`),group=as.factor(Country))) +
    geom_line(aes(y = Mean.R.,color=Country),size=1.1) +
    geom_ribbon(aes(ymin = `Quantile.0.025.R.`, ymax = `Quantile.0.975.R.`, fill = "95%CrI",color=Country),alpha=0.1) +
    geom_line(aes(y = `Quantile.0.025.R.`,color=Country),linetype=2,alpha=0.7) +
    geom_line(aes(y = `Quantile.0.975.R.`,color=Country),linetype=2,alpha=0.7) +
    geom_line(aes(y = Mean.R.,color=Country),size=1.3,alpha=0.8) +
    geom_hline(yintercept=1, linetype="dashed",  color = "black", size=1.05) +
    ggtitle("Estimated R") +
    labs(x= "Date",y="Estimated R") + geom_line(aes(y = Mean.R.),color="black",size=0.1,alpha=0.8) + ylim(c(0.2,4.8)) +
    my_theme + theme(legend.position="bottom") + ggplot2::theme(strip.text.x=element_text(size=12))+
  scale_colour_brewer(  type = "qual", palette = "Set1", direction = 1, aesthetics = "colour") +
  facet_wrap(vars(Mode),ncol=3)

```

Lowess smoothing exhibits clinically differences when compared to no smoothing, SMA or EMA smoothing.  

## Questions B, C. One-at-a-time sensitivity analysis{#OAT}

```{r oatdates}

```

We numerically evaluate the differences between different conditions by using the mean daily gap between non-overlapping $R_t$ credible intervals. The $gap$ $G_i$ at time point $i$ between two credible intervals $X$ and $Y$ obtained with the same data but some different parameter is defined as: 

$$
G_i(X_{i0.025},X_{i0.975},Y_{i0.025},Y_{i0.975}) = \left\{\begin{array}{lr}
        (1+X_{i0.025} - Y_{i0.975})^2-1, & \text{if } X_{i0.025} > Y_{i0.975} \\
        (1+Y_{i0.025} - X_{i0.975})^2-1, & \text{if } Y_{i0.025} > X_{i0.975} \\
        0, & \text{otherwise }
        \end{array}\right\}
        $$
        
where $X_{i0.975}$ and $X_{i0.025}$, respectively, are the upper and lower posterior limits of the 95% credible interval of the reproduction number at time $i$. The $gap$ defined here increases with the square of the distance between non-overlapping credible intervals.  The existence of this $gap$ between the limits of the credible intervals reflects there is room for different information and interpretations of the transmission. 

The Gap between two transmission curves is the average daily gap, defined as $G=\frac{\sum_j^N G_j}{N}$, where N is the total number of days in which both transmission curves are defined.    

### $GT$/$si${#OATsi}

```{r}

```

Daily incidences are obtained from the JHU-CSSE dataset [@JHUdata] for several countries (USA, Brazil, India, Russia, Colombia, Spain, USA, United Kingdom) between `r strftime(start_date_oat,"%d-%B-%Y")` and `r strftime(end_date_oat,"%d-%B-%Y")`, the $gap$ between pairs of $R_t$ curves obtained with different generation time distributions as the only varying parameter is calculated. As described in SupM/\@ref(SMM), many different GT and si distributions are available, including single distributions and multiple distributions. `r mcmc_length_oat` distributions are used due to computational constraints.  

Several estimation parameters are kept constant: 0% of undetected rate, backwards distribution of negative values, no specific modification of spurious positive values, centered SMA smoothing with a period or order of 4 days. The results are displayed as triangular matrix of $gap$s.  

**Spain:**  

```{r oats-Sp}
mi_kable(triangulardf(oats_Sp),caption="Sens. analysis: GT/si. Spain. Mean daily GAP") #%>% mi_kable_styling(bootstrap_options = "striped", full_width = F, position = "left")  #%>% mi_kable_styling(c("striped", "bordered"))
```

**Brazil:**  


```{r oats-Br}
mi_kable(triangulardf(oats_Br),caption="Sens. analysis: GT/si. Brazil. Mean daily GAP") #%>% mi_kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

**United States:**  

```{r oats-USA}
mi_kable(triangulardf(oats_USA),caption="Sens. analysis: GT/si. USA. Mean daily GAP") #%>%  mi_kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

**United Kingdom:**  

```{r oats-UK}
mi_kable(triangulardf(oats_UK),caption="Sens. analysis: GT/si. United Kingdom. Mean daily GAP") #%>% mi_kable_styling(bootstrap_options = "striped", full_width = F, position = "left")

```

**India:**  

```{r oats-India}
mi_kable(triangulardf(oats_India),caption="Sens. analysis: GT/si. India. Mean daily GAP") #%>% mi_kable_styling(bootstrap_options = "striped", full_width = F, position = "left")

```

**Russia:**  

```{r oats-Russia}
mi_kable(triangulardf(oats_Russia),caption="Sens. analysis: GT/si. Russia. Mean daily GAP") #%>% mi_kable_styling(bootstrap_options = "striped", full_width = F, position = "left")

```

**Colombia:**  

```{r oats-Colombia}
mi_kable(triangulardf(oats_Colombia),caption="Sens. analysis: GT/si. Colombia. Mean daily GAP") #%>% mi_kable_styling(bootstrap_options = "striped", full_width = F, position = "left")

```


#### Hierarchical clustering{#hclust}

The $gap$ function is also a dissimilarity function between credible intervals, even if this function is not a metric distance, and thus the $gap$ matrices can be used to perform hierarchical clustering. The previous pairwise $gap$ matrices of seven high-prevalence countries (USA, Brazil, India, Russia, Colombia, UK, Spain) have been mean averaged to obtain a single matrix of $si$ or $GT$ pairwise $gap$s; hierarchical clustering has been performed in this matrix (Fig \@ref(fig:oatstot)). 

```{r oatstot,fig.height=5,fig.cap="\\label{fig:oatstot} Hierarchical clustering analysis for transmission curves gap"}
oats_total <-(oats_Sp + oats_Br + oats_UK + oats_USA + oats_India + oats_Russia + oats_Colombia)/7
plot(as.dendrogram(hclust(as.dist(oats_total))),title="Distributions",nodePar=list(lab.cex=0.6,pch = c(NA, 19), 
                cex = 0.7))
```

Curves obtained with serial intervals for late-isolation (lack of stringent quarantines: $si$s from Li and Ali (with late isolation of positive cases)) were close and diverged from the rest of curves. 

### Priors

One-at-a-time sensitivity analysis of transmission curves of four countries (Spain, UK, USA, Brazil) has been performed. Constant factors include MCMC $si$ from Du, SMA smoothing with 4 days span. Several prior distributions are used; choices (mean, std) include (3, 2), (5, 2), (5, 5), (5, 7), (8, 5), (8, 7). 

**Spain:**

```{r oats-priors-Spain}
oats_func_priors<-function(incidf){
  cached_curves<-list()
  distribuciones_priors<-c("(3, 2)","(5, 2)","(5, 5)","(5, 7)","(8, 3)","(8, 5)","(8, 8)")
  oats<-as.data.frame(matrix(NA,nrow=length(distribuciones_priors),ncol=length(distribuciones_priors)));
  colnames(oats)<-rownames(oats)<-distribuciones_priors
  for (i in distribuciones_priors){
    for (j in distribuciones_priors){
      if(is.na(oats[i,j])){
        prior_i<-as.numeric((strsplit(gsub(x=i,pattern="[() ]",replacement =""),","))[[1]])
        prior_j<-as.numeric((strsplit(gsub(x=j,pattern="[() ]",replacement =""),","))[[1]])
        names(prior_i)<-names(prior_j)<-c("mean","std")
        if (!(i %in% names(cached_curves))) {cached_curves[[i]]<-future(calculate_R(incidf=incidf, smooth=4,undetected=0, mean_prior=prior_i[["mean"]],std_prior=prior_i[["std"]]),seed=TRUE)}
        if (!(j %in% names(cached_curves))) {cached_curves[[j]]<-future(calculate_R(incidf=incidf, smooth=4,undetected=0, mean_prior=prior_j[["mean"]],std_prior=prior_j[["std"]]),seed=TRUE)}
      
      }
    }
  }
  value(cached_curves)
  for (i in distribuciones_priors){
    for (j in distribuciones_priors){
      if(is.na(oats[i,j])){
        prior_i<-as.numeric((strsplit(gsub(x=i,pattern="[() ]",replacement =""),","))[[1]])
        prior_j<-as.numeric((strsplit(gsub(x=j,pattern="[() ]",replacement =""),","))[[1]])
        names(prior_i)<-names(prior_j)<-c("mean","std")
        oats[i,j]<-oats[j,i]<-if (i==j) 0 else {compareCrI(value(cached_curves[[i]]), value(cached_curves[[j]]), distance=FALSE)}
      }
    }
  }
  cached_curves<-NA;gc()
  return(oats)
}
oats_Spain<-oats_func_priors(Spain_oat)
mi_kable(triangulardf(oats_Spain),caption="Sens. analysis: Priors (mean, std). Spain. Mean daily GAP") #%>% mi_kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

**Brazil:**

```{r oats-priors-Br}
oats_Br<-oats_func_priors(Brazil_oat)
mi_kable(triangulardf(oats_Br),caption="Sens. analysis: Priors (mean, std). Br. Mean daily GAP")  #%>% mi_kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

**USA:**

```{r oats-priors-USA}
oats_USA<-oats_func_priors(US_oat)
mi_kable(triangulardf(oats_USA),caption="Sens. analysis: Priors (mean, std). USA. Mean daily GAP") #%>%mi_kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

**UK:**

```{r oats-priors-UK}
oats_UK<-oats_func_priors(UK_oat)
mi_kable(triangulardf(oats_UK),caption="Sens. analysis: Priors (mean, std). UK. Mean daily GAP") #%>% mi_kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

Using different credible intervals did not have any influence on the estimations. 

### Smoothing

For each of four countries (Spain, Brazil, USA, United Kingdom), the gap between pairs of $R_t$ curves obtained with different smoothing spans as the only varying parameter is calculated; the smoothing span is the number of points used for each point smoothing (0: no smoothing). Several estimation parameters are kept constant: undetected rate = 0% , backwards distribution of negative values, no specific modification of spurious positive values, centered SMA smoothing, $si$ distribution obtained from Du[@Du2020]. The results are displayed triangular matrixes of $gap$.  

**Spain:**

```{r smooth-Spain}
oats_func_smooth<-function(incidf){
  cached_curves<-list()
  distribuciones_smooth<-c("0","2","5","7","9")
  oats<-as.data.frame(matrix(NA,nrow=length(distribuciones_smooth),ncol=length(distribuciones_smooth)));
  colnames(oats)<-rownames(oats)<-distribuciones_smooth
  for (i in distribuciones_smooth){
    for (j in distribuciones_smooth){
      if(is.na(oats[i,j])){
        if (!(i %in% names(cached_curves))) {cached_curves[[i]]<-future(calculate_R(incidf=incidf, smooth=as.numeric(i),undetected=0, distribution="Du"),seed=TRUE)}
        if (!(j %in% names(cached_curves))) {cached_curves[[j]]<-future(calculate_R(incidf=incidf, smooth=as.numeric(j),undetected=0, distribution="Du"),seed=TRUE)}
      oats[i,j]<-oats[j,i]<-if (i==j) 0 else {compareCrI(value(cached_curves[[i]]), value(cached_curves[[j]]), distance=FALSE)}
      }
    }
  }
  return(oats)
}
oats_Sp<-oats_func_smooth(Spain_oat)
mi_kable(triangulardf(oats_Sp),caption="Sens. analysis: Smoothing. Spain. Mean daily GAP") #%>% mi_kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

**Brazil:**

```{r smooth-Brazil}
oats_Br<-oats_func_smooth(Brazil_oat) 
mi_kable(triangulardf(oats_Br),caption="Sens. analysis: Smoothing. Brazil. Mean daily GAP") #%>% mi_kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

**USA:**

```{r smooth-USA}
oats_USA<-oats_func_smooth(US_oat) 
mi_kable(triangulardf(oats_USA),caption="Sens. analysis: Smoothing. USA. Mean daily GAP") #%>% mi_kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

**UK:**

```{r smooth-UK}
oats_UK<-oats_func_smooth(UK_oat) 
mi_kable(triangulardf(oats_UK),caption="Sens. analysis: Smoothing. United Kingdom. Mean daily GAP") #%>% mi_kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

Very small differences might appear when comparing no dataset smoothing vs strong smoothing.  

### Undetected ratio

For each of four countries (Spain, Brazil, USA, United Kingdom), the $gap$ between pairs of $R_t$ curves obtained with different proportions of undetected ratio (0%, 40%, 95%; which is used to calculate the total estimated incidence) as the only varying parameter is calculated; the smoothing order is the number of points used for each point smoother. Several estimation parameters are kept constant: 0% of undetected rate, backwards distribution of negative values, no specific modification of spurious positive values, centered SMA smoothing, $si$ distribution obtained from Du[@Du2020]. The results are displayed as triangular matrix of $gap$s.  



**Spain:**

```{r ur-Spain}

oats_func_und<-function(incidf){
  cached_curves<-list()
  undetected_pct<-c("0","0.4","0.95")
  oats<-as.data.frame(matrix(NA,nrow=length(undetected_pct),ncol=length(undetected_pct)));
    colnames(oats)<-rownames(oats)<-undetected_pct
  for (i in undetected_pct){
    for (j in undetected_pct){
      if(is.na(oats[i,j])){
        if (!(i %in% names(cached_curves))) {cached_curves[[i]]<-future(calculate_R(incidf=incidf, smooth=4,undetected=as.numeric(i), distribution="Du"),seed=TRUE)}
        if (!(j %in% names(cached_curves))) {cached_curves[[j]]<-future(calculate_R(incidf=incidf, smooth=4,undetected=as.numeric(j), distribution="Du"),seed=TRUE)}
      oats[i,j]<-oats[j,i]<-if (i==j) 0 else {compareCrI(value(cached_curves[[i]]), value(cached_curves[[j]]), distance=FALSE)}
      }
    }
  }
  return(oats)
}

oats_Sp<-oats_func_und(incidf=Spain_oat)
mi_kable(triangulardf(oats_Sp),caption="Sens. analysis: Undetected ratio. Spain. Mean daily GAP") #%>% mi_kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

**Brazil:**

```{r ur-Brazil}
oats_Br<-oats_func_und(incidf=Brazil_oat)
mi_kable(triangulardf(oats_Br),caption="Sens. analysis: Undetected ratio. Brazil. Mean daily GAP") #%>% mi_kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

**USA:**

```{r ur-USA}
oats_USA<-oats_func_und(incidf=US_oat)
mi_kable(triangulardf(oats_USA),caption="Sens. analysis: Undetected ratio. USA. Mean daily GAP") #%>% mi_kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

**UK:**

```{r ur-UK}
oats_UK<-oats_func_und(incidf=UK_oat)
mi_kable(triangulardf(oats_UK),caption="Sens. analysis: Undetected ratio. United Kingdom. Mean daily GAP") #%>% mi_kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

As apparent from the GAPs, the $GT$/$si$ distribution chosen is the factor that most influences the differences in transmission curves. However the mean daily differences were small.   

## Questions A, C, E. Spain: Public health surveillance data source and estimation methods {#RENAVE}  

In Spain the New Normality Transition Plan established the daily automated and individual notification of cases to the national Health Surveillance authorities for some Epidemic indicators[@MinisterioTransicionAnexo]; thus highlighting the importance of quality individualized reports of cases, instead of plain cumulative reports. The switch between cumulative reports and individualized epidemiological reports was not easy and exemplifies the challenges that many countries faced[@EPSDatos]. The Spanish Public Health Surveillance Network (RENAVE) collects COVID-19 reports via the SIVIES system[@RENAVE], and symptoms-onset dates are used to calculate the incidence. The median diagnosis delay (interval between symptoms onset and report) was 6 days in the first wave[@RENAVEdatos](reported on 2020-05-21), but 3 days in the second wave (2020-10-26)[@RENAVEdatosOctubre]; these values are used for imputing missing onset dates (see [https://cnecovid.isciii.es/covid19/#documentaci%C3%B3n-y-datos](https://cnecovid.isciii.es/covid19/#documentaci%C3%B3n-y-datos) for details). The purpose of this section is to show the improvements in daily incidences when proper epidemiological reports are used. 

Figure \@ref(fig:PH) compares the incidence reported via the RENAVE and the deprecated previous [cumulative report of the government](last updated: 20/May/2020), for Spain, Madrid Autonomous Community, Catalonia and the Basque Community. Preprocessing parameters include SMA smoothing, 4 day smoothing span and 40% proportion of undetected cases. Figure \@ref(fig:RENAVEfig) displays the transmission curve. Estimates include $R_t$ (EpiEstim, with 3 and 7 day windows), $R^c_t$ (R0, Wallinga Teunis), $R_t$ (R0, Bettencourt Ribeiro[@Bettencourt2008], $\rho_7$. 

```{r PH, fig.cap="\\label{fig:PH} Initial cumulative incidence (Cum_MSC) vs Epidemiological reports-derived symtoms-onset based incidence (I_RENAVE)",echo=FALSE,fig.height=6,fig.width=8,eval=TRUE}
#source(paste("C:\\Users\\",userstring,"\\OneDrive\\Documentos\\myR\\libraryP.R",sep=""),encoding="UTF-8")
start_date_Sp<-as.Date("2020/02/25") 
end_date_Sp<-as.Date("2020/05/20")
datasources[["Spain_regions"]]@df<-datasources[["Spain_regions"]]@getData(datasources[["Spain_regions"]])

# Madrid

Spain_RENAVE<-get_cols(df=datasources[["Spain_regions"]]@df, province="* All *",source="Spain_regions") %>% dplyr::filter(dates>=start_date_Sp,dates<=end_date_Sp)

Spain_MSC<-get_cols(msc_csv_ag,source=MSC_str,province = "* All *") %>%  dplyr::filter(dates>=start_date_Sp,dates<=end_date_Sp)

moderesultsRENAVE<-comparemodes(list(Spain_MSC=incidf_prepro(incidf=Spain_MSC,
                      undetected=0.4, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df,
             Spain_RENAVE=incidf_prepro(incidf=Spain_RENAVE,
                      undetected=0.4,  smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df),
             mode="Spain", TD=TRUE,distributions=c("Du"),windows = c(3,7),with_inci=TRUE,with_rho7=TRUE,with_irr=c(0,6))

Madrid_RENAVE<-get_cols(df=datasources[["Spain_regions"]]@df, province="Madrid, Comunidad de",source="Spain_regions") %>% dplyr::filter(dates>=start_date_Sp,dates<=end_date_Sp)

Madrid_MSC<-get_cols(msc_csv_ag,source=MSC_str,province = "MD")  %>%   dplyr::filter(dates>=start_date_Sp,dates<=end_date_Sp)

moderesultsRENAVE<-comparemodes(list(Madrid_MSC=incidf_prepro(incidf=Madrid_MSC,
                      undetected=0.4, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df,
             Madrid_RENAVE=incidf_prepro(incidf=Madrid_RENAVE,
                      undetected=0.4,  smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df),
             mode="Madrid", TD=TRUE,distributions=c("Du"),moderesults = moderesultsRENAVE,windows = c(3,7),with_inci=TRUE,with_rho7=TRUE ,with_irr=c(0,6))

#datasources[["Spain_regions"]]@df[datasources[["Spain_regions"]]@df$ccaa_iso=="ES-PV","Name"]<-"Basque Country"
datasources[["Spain_regions"]]@df[datasources[["Spain_regions"]]@df$ccaa_iso=="ES-PV","ccaa_names"]<-"Basque Country"

BasqueCountry_RENAVE<-get_cols(df=datasources[["Spain_regions"]]@df, province="Basque Country",source="Spain_regions") %>% dplyr::filter(dates>=start_date_Sp,dates<=end_date_Sp)

BasqueCountry_MSC<-get_cols(msc_csv_ag,source=MSC_str,province = "PV")  %>%  dplyr::filter(dates>=start_date_Sp,dates<=end_date_Sp)

moderesultsRENAVE<-comparemodes(list(BasqueCountry_MSC=incidf_prepro(incidf=BasqueCountry_MSC,
                      undetected=0.4, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df,
             BasqueCountry_RENAVE=incidf_prepro(incidf=BasqueCountry_RENAVE,
                      undetected=0.4,  smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df),
             mode="BasqueCountry", TD=TRUE,distributions=c("Du"),moderesults = moderesultsRENAVE,windows = c(3,7),with_inci=TRUE,with_rho7=TRUE, with_irr=c(0,6))

VLC_RENAVE<-get_cols(df=datasources[["Spain_regions"]]@df, province="Valenciana, Comunidad",source="Spain_regions") %>% dplyr::filter(dates>=start_date_Sp,dates<=end_date_Sp) 

VLC_MSC<-get_cols(msc_csv_ag,source=MSC_str,province = "VC")  %>%  dplyr::filter(dates>=start_date_Sp,dates<=end_date_Sp)

moderesultsRENAVE<-comparemodes(list(Valencia_MSC=incidf_prepro(incidf=VLC_MSC,
                      undetected=0.4, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df,
             Valencia_RENAVE=incidf_prepro(incidf=VLC_RENAVE,
                      undetected=0.4,  smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df),
             mode="Valencia", TD=TRUE,distributions=c("Du"),moderesults = moderesultsRENAVE,windows = c(3,7),with_inci=TRUE,with_rho7=TRUE,with_irr=c(0,6))

moderesultsRENAVE$incidences$source<-sapply(moderesultsRENAVE$incidences$Country,function(x) strsplit(x,"_")[[1]][2])
moderesultsRENAVE$incidences$source<-plyr::revalue(moderesultsRENAVE$incidences$source,replace=c("MSC"="Cum_MSC","RENAVE"="I_RENAVE"))
moderesultsRENAVE$incidences$place<-sapply(moderesultsRENAVE$incidences$Country,function(x) strsplit(x,"_")[[1]][1])

add_weekdays(ggplot(moderesultsRENAVE$incidences[moderesultsRENAVE$incidences$Incidences>0 & complete.cases(moderesultsRENAVE$incidences),], aes(x = dates, y = Incidences, group = factor(source))), mindate=min(moderesultsRENAVE$incidences$dates),maxdate=max(moderesultsRENAVE$incidences$dates)) +
  #geom_line(aes(y = Incidences,color=Country,linetype=Country),size=1.7,alpha=0.8) +
  #geom_line(aes(y = Incidences),size=0,jli.2,colour="black",linetype=1) +  
  geom_line(aes(y = Incidences,color=source),size=1.7,alpha=0.8) +
      geom_vline(xintercept=as.Date("2020-03-08"), linetype="dotted",  color = "black", size=1.05) +
    geom_vline(xintercept=as.Date("2020-03-14"), linetype="solid",  color = "darkred", size=1.05) +
    geom_vline(xintercept=as.Date("2020-03-28"), linetype="dotdash",  color = "darkred", size=1.05) +
    geom_vline(xintercept=as.Date("2020-04-13"), linetype="dotdash",  color = "darkblue", size=1.05) +
    geom_vline(xintercept=as.Date("2020-05-04"), linetype="dotdash",  color = "black", size=1.05) +
    #geom_line(aes(y = Incidences,color=Country,linetype=Country),size=1,alpha=0.8) +
    ggtitle("Cumulative vs Individualized reports")+ #scale_fill_discrete(name = "Country", labels = EU) +
    labs(x=element_blank(),y="Daily incidence") + my_theme +ggplot2::theme(
                axis.title.x=element_blank()) +  
  scale_y_continuous(trans='log10',limits=c(10,20000))+ #xlim(min(incidences$dates),max(incidences$dates)) +
   guides(colour = guide_legend(override.aes = list(alpha = 1))) + scale_color_brewer(type="Qual",palette="Set1")+facet_wrap(facets = vars(place)) 
```


```{r RENAVEfig, fig.cap="\\label{fig:RENAVEfig} $R_t$ estimates for Spain and regions (Government vs public health data source). Highlighted dates: 2020-03-08 (8M), 2020-03-14 (State of Alarm), 2020-03-28 (Economic stop), 2020-04-13 (Partial economic restart), 2020-05-04 (Return to 'normal', phase 0). Estimates: Bettencourt and Ribeiro (R0 package), $R_t$ (EpiEstim) with 3-day windows, $R_t$ (EpiEstim) EpiEstim with 7-day windows, $rho_{7}$, $R^c_t$ (Wallinga Teunis, R0 package)",echo=FALSE,fig.height=10,fig.width=9,eval=TRUE}

moderesultsRENAVE$data_to_plot<-rbind(moderesultsRENAVE$data_to_plot,(moderesultsRENAVE$empiricalR %>%
                                  dplyr::mutate(date_start=dates,date_end=dates,`Mean.R.`=rho7, `Quantile.0.025.R.`=rho7,
                                `Quantile.0.975.R.`=rho7,Method="rho7",distr="rho7",Mode=Mode))[,colnames(moderesultsRENAVE$data_to_plot)])

moderesultsRENAVE$data_to_plot$source<-as.factor(sapply(as.character(moderesultsRENAVE$data_to_plot$Country),function(x) strsplit(x,"_")[[1]][2])) 
ggplot(moderesultsRENAVE$data_to_plot[complete.cases(moderesultsRENAVE$data_to_plot),], aes(x = date_end, y = as.numeric(`Mean.R.`), group = source)) + 
    geom_line(aes(y = Mean.R.,color=source),size=1.1) +
    geom_ribbon(aes(ymin = `Quantile.0.025.R.`, ymax = `Quantile.0.975.R.`), fill = "grey70",alpha=0.3) +
    geom_line(aes(y = `Quantile.0.025.R.`,color=source),linetype=2,alpha=0.7) +
    geom_line(aes(y = `Quantile.0.975.R.`,color=source),linetype=2,alpha=0.7) +
    geom_line(aes(y = Mean.R.,color=source),size=1.3,alpha=0.8) +   
    geom_hline(yintercept=1, linetype="dashed",  color = "black", size=1.05) +
      geom_vline(xintercept=as.Date("2020-03-08"), linetype="dotted",  color = "black", size=1.05) +
    geom_vline(xintercept=as.Date("2020-03-14"), aes(color="State of Alarm"), linetype="solid",   size=1.05) +
    geom_vline(xintercept=as.Date("2020-03-28"), linetype="dotdash",  color = "darkred", size=1.05) +
    geom_vline(xintercept=as.Date("2020-04-13"), linetype="dotdash",  color = "darkblue", size=1.05) +
    geom_vline(xintercept=as.Date("2020-05-04"), linetype="dotdash",  color = "black", size=1.05) +
    #ggtitle("Estimated R")+scale_fill_discrete(name = "Country", labels = EU) +
    labs(x= "Date",y="Estimated R") + geom_line(aes(y = Mean.R.),color="black",size=0.1,alpha=0.8) + ylim(c(0.2,4.8)) +
    my_theme_12 +
  scale_colour_brewer(  type = "qual", palette = "Set1", direction = 1, aesthetics = "colour") + facet_grid(cols=vars(Mode),rows=vars(Method))#+ 
  # scale_color_manual(name = "dates", values = c(`8M` = "purple", `State of alarm` = "darkred",`Economy frozen`="darkred",`Economy reopened`="darkblue",`Reopening`="Black"))
#estimate_R_plots(estimates,what="R",legend=TRUE)+scale_fill_discrete(name = "Country", labels = EU)
#estimate_R_plots(estimates,what="incid",legend=TRUE)+scale_fill_discrete(name = "Country", labels = EU)

```

The Bettencourt and Ribeiro method, as implemented in the R0 package, showed a different pattern, so this has not been further analyzed. The calculated $\rho_7$ showed some clinically relevant divergences at the end. The rest of the estimation methods show noticeable or non-existent differences. The epidemiological symptoms-onset report-based dataset is less prone to weekday bias (which was particularly important when the incidence was decreasing) and exhibits the effect of the diagnosis/reporting delay in the cumulative data; these differences are noticeable but they are not clinically relevant. The interpretation is consistent across estimators: $R_t$ reached control level in March, and this preceded or was simultaneous with incidence curves bending. 

## Questions B. Catalonia: Confirmed vs suspected cases, weekend smoothing, estimation methods{#CatSmooth}

The [official Catalonia open data COVID-19 repository](http://governobert.gencat.cat/en/dades_obertes/dades-obertes-covid-19/evolucio-de-la-covid-19-a-catalunya/)[@Catalonia] has been analyzed. This data includes several time series corresponding to different case definitions: Positive PCR, antibodies test, rapid tests, epidemiologic cases, probable cases; thus providing insights on the evolution of suspected vs confirmed cases over time. Additionally, the impact of smoothing and the **weekday bias** (a decrease in the assumed daily incidence in the weekends due to the laboratories/institutions having reduced activity). 

The application and code have been used to obtain epidemic and transmission curves. Mild smoothing is defined as **3** days of smoothing with the "centered SMA" method, and Strong smoothing is defined as **7** days of smoothing with the "centered SMA" method; other parameters include: backward distribution of negative values, and 0% undetected rate. Figure \@ref(fig:csu2) displays the epidemic curves after pre-processing and figure \@ref(fig:estimations-csu) displays the transmission curves.  

```{r csu,eval=TRUE}
csu_start_date<-start_date<-as.Date("2020/02/01")
csu_end_date<-end_date<-as.Date("2020/06/25" ) 
cat_z$TipusCasDescripcio<-as.character(cat_z$TipusCasDescripcio)
#print(cat_z)
CAT_S<-cat_z[cat_z$TipusCasDescripcio %in% c("Sospitós","PCR probable","Epidemiològic"),c("TipusCasData","NumCasos")] %>%
          dplyr::group_by(TipusCasData) %>% dplyr::summarize(I= sum(NumCasos,na.rm=TRUE)) %>% 
        dplyr::mutate(dates=as.Date(TipusCasData,"%d/%m/%Y")) %>% tidyr::drop_na() %>%
        dplyr::select(c("dates","I"))
 
CAT_SC<-get_cols(cat_z,source=CAT_zsc_str,country="* All *", province="* All *")
CAT_C<-get_cols(cat_z,source=CAT_zc_str,country="* All *", province="* All *")
CAT_CR<-get_cols(cat_z,source=CAT_zcr_str,country="* All *", province="* All *")
CAT_AB<-get_cols(cat_z,source=CAT_zabs_str,country="* All *", province="* All *")
CAT_RAP<-cat_z[cat_z$TipusCasDescripcio=="Positiu per Test Ràpid",c("TipusCasData","NumCasos")] %>%
          dplyr::group_by(TipusCasData) %>% dplyr::summarize(I= sum(NumCasos,na.rm=TRUE)) %>% 
        dplyr::mutate(dates=as.Date(TipusCasData,"%d/%m/%Y")) %>% tidyr::drop_na() %>%
        dplyr::select(c("dates","I"))

```


```{r csu2,eval=TRUE, fig.width=11, fig.height=7,fig.cap="\\label{fig:csu2} Epidemic curve of Catalonia. Highlighted dates: 2020-03-14 (State of Alarm); 2020-05-04 (Phase zero, reopening); 2020-06-21 (End of the State of Alarm)"}
  

moderesultscsu<-comparemodes(list(Cat_PCR=incidf_prepro(incidf=CAT_C,
                      undetected=0.0, smooth_method="SMA (centered)", smooth_value=3, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter (dates<=csu_end_date,dates>=csu_start_date), 
             Cat_Susp=incidf_prepro(incidf=CAT_S,
                      undetected=0.0,  smooth_method="SMA (centered)", smooth_value=3, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter (dates<=csu_end_date,dates>=csu_start_date), 
             Cat_Susp_Conf=incidf_prepro(incidf=CAT_SC,
                      undetected=0.0,  smooth_method="SMA (centered)", smooth_value=3, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter (dates<=csu_end_date,dates>=csu_start_date), 
             Cat_Abs=incidf_prepro(incidf=CAT_AB,
                      undetected=0.0,  smooth_method="SMA (centered)", smooth_value=3, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter (dates<=csu_end_date,dates>=csu_start_date), 
             CAT_RAP=incidf_prepro(incidf=CAT_RAP,
                      undetected=0.0,  smooth_method="SMA", smooth_value=3, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter (dates<=csu_end_date,dates>=csu_start_date) ),mode="Catalonia, 3 day smoothing", TD=TRUE,distributions=c("Du"),with_inci=TRUE,window=c(3,7), with_rho7 = TRUE,with_irr=c(0,6))

moderesultscsu$incidences_final<-moderesultscsu$incidences %>% mutate(smooth="Mild")
moderesultscsu$incidences_long <- moderesultscsu$incidences<-data.frame()  

moderesultscsu<-comparemodes(list(Cat_PCR=incidf_prepro(incidf=CAT_C,
                      undetected=0.0, smooth_method="SMA (centered)", smooth_value=7, ignore=15,warnings="",negatives=dbfs)$df  %>% dplyr::filter (dates<=csu_end_date,dates>=csu_start_date),
             Cat_Susp=incidf_prepro(incidf=CAT_S,
                      undetected=0.0,  smooth_method="SMA (centered)", smooth_value=7, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter (dates<=csu_end_date,dates>=csu_start_date), 
             Cat_Susp_Conf=incidf_prepro(incidf=CAT_SC,
                      undetected=0.0,  smooth_method="SMA (centered)", smooth_value=7, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter (dates<=csu_end_date,dates>=csu_start_date), 
             Cat_Abs=incidf_prepro(incidf=CAT_AB,
                      undetected=0.0,  smooth_method="SMA (centered)", smooth_value=7, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter (dates<=csu_end_date,dates>=csu_start_date), 
             CAT_RAP=incidf_prepro(incidf=CAT_RAP,
                      undetected=0.0,  smooth_method="SMA (centered)", smooth_value=7, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter (dates<=csu_end_date,dates>=csu_start_date)),mode="Catalonia, 7 day smoothing", TD=TRUE,distributions=c("Du"),moderesults=moderesultscsu,with_inci=TRUE,window=c(3,7), with_rho7=TRUE, with_irr=c(0,6)) 

moderesultscsu$incidences_final<-rbind(moderesultscsu$incidences %>% mutate(smooth="Strong"),moderesultscsu$incidences_final)

 
moderesultscsu$incidences$dates<-as.Date(moderesultscsu$incidences$dates)

add_weekdays(ggplot(moderesultscsu$incidences_final[moderesultscsu$incidences_final$Incidences>0 & complete.cases(moderesultscsu$incidences_final),], aes(x = dates, y = Incidences, group = factor(Country))), mindate=min(moderesultscsu$incidences$dates),maxdate=max(moderesultscsu$incidences$dates)) +
  #geom_line(aes(y = Incidences,color=Country,linetype=Country),size=1.7,alpha=0.8) +
  #geom_line(aes(y = Incidences),size=0,jli.2,colour="black",linetype=1) +  
  geom_line(aes(y = Incidences,color=Country),size=1.7,alpha=0.8) +
  geom_vline(xintercept=as.Date("2020-03-14")) +
  geom_text(aes(x = as.Date("2020-03-14"),y=10000,label="2020-03-14"),text=element_text(size=14),vjust=+1,hjust=1)+
  geom_vline(xintercept=as.Date("2020-05-04")) +
  geom_text(aes(x = as.Date("2020-05-04"),y=10000,label="2020-05-04"),text=element_text(size=14),vjust=+1,hjust=1)+
  geom_vline(xintercept=as.Date("2020-06-21")) +
  geom_text(aes(x = as.Date("2020-06-21"),y=10000,label="2020-06-21"),text=element_text(size=14),vjust=+1,hjust=1)+
    #geom_line(aes(y = Incidences,color=Country,linetype=Country),size=1,alpha=0.8) +
    ggtitle("Catalonia")+ #scale_fill_discrete(name = "Country", labels = EU) +
    labs(x=element_blank(),y="Daily incidence") + my_theme + ggplot2::theme( 
                axis.title.x=element_blank()) + 
  scale_y_continuous(trans='log10',limits=c(10,15000))+ #xlim(min(incidences$dates),max(incidences$dates)) +
   guides(colour = guide_legend(override.aes = list(alpha = 1))) + scale_color_brewer(type="Qual",palette="Set1")+facet_grid(cols = vars(smooth))
 
 
```

In Catalonia epidemic curves show a weekday/weekend bias: the reported incidence decreases in weekends, maybe due to laboratory and personnel workflows, thus overestimating weekdays incidences and underestimating weekends indidences.  

The number of positive PCRs has decreased over time after the March epidemic peak, signaling an effective epidemic control. On the other hand suspected cases have kept increasing after the epidemic peak while the confirmed cases declined; this could be explained by many reasons/hypotheses (non-specific symptoms associated with COVID-19, seasonal allergies, increased public awareness, increased Primary Care and Public Health throughput and tracing infrastructure, a shifting from care-at-home to early testing approach...), but in any case it demonstrates clinically relevant differences between curves exist and suspected cases cannot be reliably used as a surrogate for undetected cases or total cases early in the epidemic, at least in this dataset. In the second wave, these cases followed the PCR increases.  

Variability exists between regions and countries regarding the reporting/management of suspected cases. In the epidemic peak many countries and guidelines don't require a PCR is performed in all suspected cases due to constrained resources.  

```{r estimations-csu, fig.cap="\\label{fig:estimations-csu} $R_t$ estimates for Catalonia. Highlighted dates: 2020-03-08 (8M), 2020-03-14 (State of Alarm), 2020-03-28 (Economic stop), 2020-04-13 (Partial economic restart), 2020-05-04 (Return to 'normal' (phase 0)), gradual reopening, 2020-06-21 (End of State of Alarm). Estimates: Bettencourt and Ribeiro (R0 package), $R_t$ (EpiEstim) with 3-day windows, $R_t$ (EpiEstim) EpiEstim with 7-day windows, $rho_{7}$, $R^c_t$ (Wallinga Teunis, R0 package)",echo=FALSE,fig.height=9,fig.width=8,eval=TRUE}
   
moderesultscsu$data_to_plot<-rbind(moderesultscsu$data_to_plot,(moderesultscsu$empiricalR %>%
                                  dplyr::mutate(date_start=dates,date_end=dates,`Mean.R.`=rho7, `Quantile.0.025.R.`=rho7, 
                                `Quantile.0.975.R.`=rho7,Method="rho7",distr="rho7",Mode=Mode))[,colnames(moderesultscsu$data_to_plot)])

moderesultscsu$data_to_plot<-moderesultscsu$data_to_plot %>% rename(Cases=Country,dates=date_end) %>% mutate (dates=as.Date(dates))
 
add_weekdays(ggplot(moderesultscsu$data_to_plot[complete.cases(moderesultscsu$data_to_plot) & moderesultscsu$data_to_plot$Cases %in% c("Cat_PCR","Cat_Susp_Conf"),], aes(x = dates, y = as.numeric(`Mean.R.`), group = as.factor(Cases))),
             mindate=min(moderesultscsu$incidences$dates),maxdate=max(moderesultscsu$incidences$dates)) +
    geom_line(aes(y = Mean.R.,color=Cases),size=1.1) +
    geom_ribbon(aes(ymin = `Quantile.0.025.R.`, ymax = `Quantile.0.975.R.`, color=Cases),alpha=0.1) +
    geom_line(aes(y = `Quantile.0.025.R.`,color=Cases),linetype=2,alpha=0.7) +
    geom_line(aes(y = `Quantile.0.975.R.`,color=Cases),linetype=2,alpha=0.7) +  
    geom_line(aes(y = Mean.R.,color=Cases),size=1.3,alpha=0.8) +
    geom_hline(yintercept=1, linetype="dashed",  color = "black", size=1.05) +
    #ggtitle("Estimated R")+scale_fill_discrete(name = "Country", labels = EU) +
    labs(x= "Date",y="Estimated R") + geom_line(aes(y = Mean.R.),color="black",size=0.1,alpha=0.8) + ylim(c(0.2,4.8)) +
  geom_vline(xintercept=as.Date("2020-03-08"), linetype="dotted",  color = "black", size=1.05) +
    geom_vline(xintercept=as.Date("2020-03-14"), linetype="solid",  color = "darkred", size=1.05) +
    geom_vline(xintercept=as.Date("2020-03-28"), linetype="dotdash",  color = "darkred", size=1.05) +
    geom_vline(xintercept=as.Date("2020-04-13"), linetype="dotdash",  color = "darkblue", size=1.05) +
    geom_vline(xintercept=as.Date("2020-05-04"), linetype="dotdash",  color = "black", size=1.05) +
  geom_vline(xintercept=as.Date("2020-05-18"), linetype="dotdash",  color = "black", size=0.8) +
  geom_vline(xintercept=as.Date("2020-05-25"), linetype="dotdash",  color = "black", size=0.8) +
  geom_vline(xintercept=as.Date("2020-06-01"), linetype="dotdash",  color = "black", size=0.8) +
  geom_vline(xintercept=as.Date("2020-06-21"), linetype="solid",  color = "darkblue", size=1.05) +
my_theme_13 +
  scale_colour_brewer(  type = "qual", palette = "Set1", direction = 1, aesthetics = "colour") + facet_grid(cols=vars(Mode),rows = vars(Method))+
   geom_rect(mapping=aes(xmin=min(moderesultscsu$data_to_plot$dates),xmax=min(moderesultscsu$data_to_plot$dates),ymin=0,ymax=0,fill="Weekdays"),alpha=0.3)+lims(y=c(0,5))
#estimate_R_plots(estimates,what="R",legend=TRUE)+scale_fill_discrete(name = "Country", labels = EU)
#estimate_R_plots(estimates,what="incid",legend=TRUE)+scale_fill_discrete(name = "Country", labels = EU)
 
 
```

Both smoothing the time series and using longer time windows for the estimations can reduce the impact of weekend fluctuations in the epidemic curves and in the transmission curves. Smoothing should be considered carefully: EpiEstim by default estimates $R_t$ over 7-day windows, and smoothed estimates apparently exhibit less weekday-effect than daily estimates on smoothed datasets. Some estimates and settings might be more prone than others to weekday-bias. This Wallinga-Teunis method implementation lacks estimate smoothing, so time series smoothing can be considered. $\rho_7$ and EpiEstim $R_t$ do not require strong smoothing. 

## Questions B, C, G. Belgium: The impact of smoothing and estimation methods, and other transmission indicators {#smoothBelgium}

```{r csubeldates}
csubelstart<-as.Date("2020-03-05")
csubelend<-as.Date("2021-03-05")
```

The [official Belgium dataset, collected by the Sciensano institute,](https://epistat.wiv-isp.be/covid/)[@Belgium] has been analyzed using the application and code to assess the impact of smoothing and the "weekday bias". Mild smoothing is defined as **3** days of smoothing with the "centered SMA" method, and Strong smoothing is defined as **7** days of smoothing with the "centered SMA" method; other parameters are: negative values are distributed backwards before smoothing, spurious positive peaks are not removed and the undetected rate is zero. Dates between `r csubelstart` and `r csubelend` have been included. Figure \@ref(fig:bel) displays the epidemic curves after preprocessing and figure \@ref(fig:estimationscsubel) displays the transmission curves.  

```{r belcalc,warning=FALSE,error=FALSE,message=FALSE}
    
datasources[["BEL"]]@df<-datasources[["BEL"]]@getData(datasources[["BEL"]])

Flanders<-get_cols(datasources[["BEL"]]@df,source=datasources[["BEL"]]@name,country="Flanders", province="* All *") %>% filter(dates>as.Date(csubelstart),dates<as.Date(csubelend))
Brussels<-get_cols(datasources[["BEL"]]@df,source=datasources[["BEL"]]@name,country="Brussels", province="* All *") %>% filter(dates>as.Date(csubelstart),dates<as.Date(csubelend))
Wallonia<-get_cols(datasources[["BEL"]]@df,source=datasources[["BEL"]]@name,country="Wallonia", province="* All *") %>% filter(dates>as.Date(csubelstart),dates<as.Date(csubelend))


moderesultscsu<-comparemodes(list(Flanders=incidf_prepro(incidf=Flanders,
                      undetected=0.0, smooth_method="SMA (centered)", smooth_value=3, ignore=15,warnings="",negatives=dbfs)$df,
             Brussels=incidf_prepro(incidf=Brussels,
                      undetected=0.0,  smooth_method="SMA (centered)", smooth_value=3, ignore=15,warnings="",negatives=dbfs)$df,
             Wallonia=incidf_prepro(incidf=Wallonia,
                      undetected=0.0,  smooth_method="SMA (centered)", smooth_value=3, ignore=15,warnings="",negatives=dbfs)$df),
             mode="Belgium, 3d smooth", TD=TRUE,distributions=c("Du"),with_inci=TRUE,windows = c (3,7),with_rho7=TRUE) 

moderesultscsu$incidences_final<-moderesultscsu$incidences %>% mutate(smooth="Mild")

moderesultscsu<-comparemodes(list(Flanders=incidf_prepro(incidf=Flanders,
                      undetected=0.0, smooth_method="SMA (centered)", smooth_value=7, ignore=15,warnings="",negatives=dbfs)$df,
             Brussels=incidf_prepro(incidf=Brussels,
                      undetected=0.0,  smooth_method="SMA (centered)", smooth_value=7, ignore=15,warnings="",negatives=dbfs)$df,
             Wallonia=incidf_prepro(incidf=Wallonia,
                      undetected=0.0,  smooth_method="SMA (centered)", smooth_value=7, ignore=15,warnings="",negatives=dbfs)$df),
             mode="Belgium, 7d smooth", TD=TRUE,distributions=c("Du"),moderesults=moderesultscsu,with_inci=TRUE,windows = c (3,7),with_rho7=TRUE)

moderesultscsu$incidences_final<-rbind(moderesultscsu$incidences %>% mutate(smooth="0 Smooth"),moderesultscsu$incidences_final)
 
moderesultscsu<-comparemodes(list(Flanders=incidf_prepro(incidf=Flanders,
                      undetected=0.0, smooth_method="none", smooth_value=7, ignore=20,warnings="",negatives=dbfs)$df,
             Brussels=incidf_prepro(incidf=Brussels,
                      undetected=0.0,  smooth_method="none", smooth_value=7, ignore=20,warnings="",negatives=dbfs)$df,
             Wallonia=incidf_prepro(incidf=Wallonia,
                      undetected=0.0,  smooth_method="none", smooth_value=7, ignore=20,warnings="",negatives=dbfs)$df), 
             mode="Belgium, 0 smooth", TD=TRUE,distributions=c("Du"),moderesults=moderesultscsu,with_inci=TRUE,windows = c (3,7),with_rho7=TRUE)

moderesultscsu$incidences_final$dates<-as.Date(moderesultscsu$incidences_final$dates)
moderesultscsu$incidences_final$Region<-moderesultscsu$incidences_final$Country
 
```

```{r bel, warning=FALSE,error=FALSE,message=FALSE,fig.width=8,fig.height=5,fig.cap="\\label{fig:bel} Epidemic curves of Belgium"}
   
add_weekdays(ggplot(moderesultscsu$incidences[moderesultscsu$incidences$Incidences>0 & complete.cases(moderesultscsu$incidences),] %>% dplyr::rename(Region=Country), aes(x = dates, y = Incidences, group = factor(Region))),  mindate=min(moderesultscsu$incidences$dates),maxdate=max(moderesultscsu$incidences$dates)) +
  #geom_line(aes(y = Incidences,color=Country,linetype=Country),size=1.7,alpha=0.8) +
  #geom_line(aes(y = Incidences),size=0,jli.2,colour="black",linetype=1) +  
  geom_line(aes(y = Incidences,color=Region),size=0.7,alpha=0.8) + 
    #geom_line(aes(y = Incidences,color=Country,linetype=Country),size=1,alpha=0.8) +
    ggtitle("Belgium")+ #scale_fill_discrete(name = "Country", labels = EU) +
    labs(x=element_blank(),y="Daily incidence") + my_theme_13 + theme_bottom_legend +
  scale_y_continuous(trans='log10',limits=c(10,max(moderesultscsu$incidences_final$Incidences)))+ #xlim(min(incidences$dates),max(incidences$dates)) +
   guides(colour = guide_legend(override.aes = list(alpha = 1))) + scale_color_brewer(type="Qual",palette="Set1")+facet_grid(cols = vars(Mode)) 
   
```

```{r estimationscsubel, fig.cap="\\label{fig:estimationscsubel} Transmission curves of Belgium. Different methods are shown, including $R_t$ estimated over 7-day and 3-day windows, $R^c_t$ (Wallinga Teunis) and $rho_{7}$(direct calculation). ",echo=FALSE,fig.height=10,fig.width=8,eval=TRUE}
  
moderesultscsu$data_to_plot<-rbind(moderesultscsu$data_to_plot,(moderesultscsu$empiricalR %>% 
                                  dplyr::mutate(date_start=dates,date_end=dates,`Mean.R.`=rho7, `Quantile.0.025.R.`=rho7,
                                 `Quantile.0.975.R.`=rho7,Method="rho7",distr="rho7",Mode=Mode))[,colnames(moderesultscsu$data_to_plot)]) 

moderesultscsu$data_to_plot<-moderesultscsu$data_to_plot %>% rename(Region=Country,dates=date_end) %>% mutate (dates=as.Date(dates))

add_weekdays(ggplot(moderesultscsu$data_to_plot[complete.cases(moderesultscsu$data_to_plot),], aes(x = dates, y = as.numeric(`Mean.R.`), group = as.factor(Region))),mindate=min(moderesultscsu$data_to_plot$dates),maxdate=max(moderesultscsu$data_to_plot$dates)) +
    geom_line(aes(y = Mean.R.,color=Region),size=0.7) +
    #geom_ribbon(aes(ymin = `Quantile.0.025.R.`, ymax = `Quantile.0.975.R.`,color=Region),alpha=0.01) +
    geom_line(aes(y = `Quantile.0.025.R.`,color=Region),size=0.2,linetype=1.5,alpha=0.7) +  
    geom_line(aes(y = `Quantile.0.975.R.`,color=Region),size=0.2,linetype=1.5,alpha=0.7) +
    #geom_line(aes(y = Mean.R.,color=Regions),size=1.3,alpha=0.8) +  
    geom_hline(yintercept=1, linetype="dashed",  color = "black", size=1.05) + 
    #ggtitle("Estimated R")+scale_fill_discrete(name = "Country", labels = EU) +
    labs(x= "Date",y="Estimated R")  +  #ylim(c(0.2,4.8)) + geom_line(aes(y = Mean.R.),color="black",size=0.1,alpha=0.8) +
    my_theme_13+lims(y=c(0.2,4))+
  scale_colour_brewer(type = "qual", palette = "Set1", direction = 1, aesthetics = "colour") + facet_grid(cols=vars(Mode),rows = vars(Method)) + theme_bottom_legend +
  geom_rect(mapping=aes(xmin=min(moderesultscsu$data_to_plot$dates),xmax=min(moderesultscsu$data_to_plot$dates),ymin=0,ymax=0,fill="Weekdays"),alpha=0.3)
#estimate_R_plots(estimates,what="R",legend=TRUE)+scale_fill_discrete(name = "Country", labels = EU)
#estimate_R_plots(estimates,what="incid",legend=TRUE)+scale_fill_discrete(name = "Country", labels = EU)

```

As seen in the case of Catalonia, using smaller window periods for the $R_t$ estimation is equivalent to using smaller SMA smoothing periods. The differences between Belgian divisions are *noticeable* but small, and the $R_t$ intervals become wider as the incidence decreases. 

## Question E. USA: The state estimates of a developed country{#USAstates}

```{r usat}
start_date_USA<-as.Date("2020/03/15")
end_date_USA<-as.Date("2021-06-10"  )
```

The state-level number of cases from the USA between `r strftime(start_date_USA,"%d-%B-%Y")` and `r strftime(end_date_USA,"%d-%B-%Y")` has been analyzed; [dataset is from The New York Times, based on reports from state and local health agencies](https://www.nytimes.com/interactive/2020/us/coronavirus-us-cases.html)[@NYT]. Preprocessing options include SMA centered smoothing, 7 day as smoothing span. Figure \@ref(fig:incidenciasUSA) displays the epidemic curve after preprocessing and figure  \@ref(fig:estimations-USA) displays the transmission curves; in the transmission curve the states have been colored according to their GDP per capita (purchase power parity, current prices) [@OECD] and in the epidemic curve the date of the death of George Floyd has been highlighted, after which riots ensued (section \@ref(superspreadingresults)). Regional GDP per capita (US dollars, current prices, current purchasing power parity) data from OECD for 2018 (USA) [@OECD] was used to color the transmission curves. 

```{r USA}


USA_states<-list()

for (country in as.character(levels(USAs_csv$state))){
  USA_states[[country]]<-incidf_prepro(fdf_to_inci(USAs_csv %>% filter(state==country) %>% mutate (dates=as.Date(date,"%Y-%m-%d"),Cum=cases)), undetected=0.4,  smooth_method="SMA (centered)", smooth_value=7, ignore=15,warnings="",negatives=dbfs)$df %>% filter(dates>start_date_USA,dates<=end_date_USA);
  if (sum(USA_states[[country]]$I)<2000) USA_states[[country]]<-NULL
}
moderesultsUSA<-comparemodes(USA_states,mode="USA_states",window = 7,TD=FALSE,with_inci=TRUE,distributions = "Du",with_rho7 = TRUE)


```


```{r incidenciasUSA, echo=FALSE, fig.cap="\\label{fig:incidenciasUSA} COVID-19 incidence in several USA states", fig.height=16, fig.width=11}
moderesultsUSA$incidences$graph<-floor((as.numeric(factor(moderesultsUSA$incidences$Country))-1)/10) 
ggarrange(
add_weekdays(ggplot(moderesultsUSA$incidences[moderesultsUSA$incidences$Incidences>1 & moderesultsUSA$incidences$graph==0,] %>% tidyr::drop_na(), aes(x = dates, y = Incidences ,group=Country)),mindate=min(moderesultsUSA$incidences$dates),maxdate=max(moderesultsUSA$incidences$dates)) +
    geom_line(aes(y = Incidences,colour=Country),size=1.1) +
    labs(x= "Date",y="Daily incidence") + ggplot2::theme(
            legend.position="bottom",legend.title=element_blank(),
            axis.title.x=element_blank(),axis.title.y=element_blank(),
                axis.text.x = element_text(size = 14),
                axis.text.y = element_text(size = 14)) + scale_y_continuous(trans='log10') +my_theme_13+
    scale_colour_brewer(  type = "qual", palette = "Paired", direction = 1, aesthetics = "colour")+ guides(col=guide_legend(nrow=5)),
add_weekdays(ggplot(moderesultsUSA$incidences[moderesultsUSA$incidences$Incidences>1 & moderesultsUSA$incidences$graph==1,] %>% tidyr::drop_na(), aes(x = dates, y = Incidences ,group=Country)),mindate=min(moderesultsUSA$incidences$dates),maxdate=max(moderesultsUSA$incidences$dates)) +
    geom_line(aes(y = Incidences,colour=Country),size=1.1) +
    labs(x= "Date",y="Daily incidence") + ggplot2::theme(
            legend.position="bottom",legend.title=element_blank(),
            axis.title.x=element_blank(),axis.title.y=element_blank(),
                axis.text.x = element_text(size = 14),
                axis.text.y = element_text(size = 14)) + scale_y_continuous(trans='log10') +my_theme_13+
    scale_colour_brewer(  type = "qual", palette = "Paired", direction = 1, aesthetics = "colour")+
  guides(col=guide_legend(nrow=5)),
add_weekdays(ggplot(moderesultsUSA$incidences[moderesultsUSA$incidences$Incidences>1 & moderesultsUSA$incidences$graph==2,] %>% tidyr::drop_na(), aes(x = dates, y = Incidences ,group=Country)),mindate=min(moderesultsUSA$incidences$dates),maxdate=max(moderesultsUSA$incidences$dates)) +
    geom_line(aes(y = Incidences,colour=Country),size=1.1) +
    labs(x= "Date",y="Daily incidence") + ggplot2::theme(
            legend.position="bottom",legend.title=element_blank(),
            axis.title.x=element_blank(),axis.title.y=element_blank(),
                axis.text.x = element_text(size = 14),
                axis.text.y = element_text(size = 14)) + scale_y_continuous(trans='log10') + my_theme_13+
    scale_colour_brewer(  type = "qual", palette = "Paired", direction = 1, aesthetics = "colour")+ guides(col=guide_legend(nrow=5)), 
add_weekdays(ggplot(moderesultsUSA$incidences[moderesultsUSA$incidences$Incidences>1 & moderesultsUSA$incidences$graph==3,] %>% tidyr::drop_na(), aes(x = dates, y = Incidences ,group=Country)),mindate=min(moderesultsUSA$incidences$dates),maxdate=max(moderesultsUSA$incidences$dates)) +
    geom_line(aes(y = Incidences,colour=Country),size=1.1) +
    labs(x= "Date",y="Daily incidence") + ggplot2::theme(
            legend.position="bottom",legend.title=element_blank(),
            axis.title.x=element_blank(),axis.title.y=element_blank(),
                axis.text.x = element_text(size = 14),
                axis.text.y = element_text(size = 14)) + scale_y_continuous(trans='log10') +my_theme_13+
    scale_colour_brewer(  type = "qual", palette = "Paired", direction = 1, aesthetics = "colour")+ guides(col=guide_legend(nrow=5)),
add_weekdays(ggplot(moderesultsUSA$incidences[moderesultsUSA$incidences$Incidences>1 & moderesultsUSA$incidences$graph==4,] %>% tidyr::drop_na(), aes(x = dates, y = Incidences ,group=Country)),mindate=min(moderesultsUSA$incidences$dates),maxdate=max(moderesultsUSA$incidences$dates)) +
    geom_line(aes(y = Incidences,colour=Country),size=1.1) +
    labs(x= "Date",y="Daily incidence") + ggplot2::theme( 
            legend.position="bottom",legend.title=element_blank(),
            axis.title.x=element_blank(),axis.title.y=element_blank(),
                axis.text.x = element_text(size = 14),
                axis.text.y = element_text(size = 14)) + scale_y_continuous(trans='log10') +my_theme_13+
    scale_colour_brewer(  type = "qual", palette = "Paired", direction = 1, aesthetics = "colour")+ guides(col=guide_legend(nrow=5)),ncol=3,nrow=2) 
 
```


```{r estimations-USA, fig.cap="\\label{estimations-USA}$R_t$ estimates for USA states",echo=FALSE,fig.height=14,fig.width=11}
#(incidences_Sp %>% group_by(Community) %>% summarize (N=sum(Incidences)) %>% dplyr::filter(N>7000))$Community),]
#moderesultsUSA$data_to_plot$graph<-floor((as.numeric(factor(moderesultsUSA$data_to_plot$Country))-1)/9)

#moderesultsUSA$data_to_plot<-rbind(moderesultsUSA$data_to_plot,(moderesultsUSA$empiricalR %>%
#                                  dplyr::mutate(date_start=dates,date_end=dates,`Mean.R.`=rho7, `Quantile.0.025.R.`=rho7,
#                                `Quantile.0.975.R.`=rho7,Method="rho7",distr="rho7",Mode="",))[,colnames(moderesultsUSA$data_to_plot)])

moderesultsUSA$data_to_plot  <- moderesultsUSA$data_to_plot %>% dplyr::rename(State=Country) %>%
  merge(USA_PPC[,c("Region","Value")] %>% dplyr::rename(State=Region),by="State") %>% dplyr::rename(GDP_USD_PC=Value) 

ggplot(moderesultsUSA$data_to_plot %>% dplyr::filter(Method!="Wallinga Teunis"), aes(x = date_end, y = as.numeric(`Mean.R.`),colour=GDP_USD_PC)) + 
    geom_line(aes(y = Mean.R.,colour=GDP_USD_PC),size=1.15) + 
    geom_ribbon(aes(ymin = `Quantile.0.025.R.`, ymax = `Quantile.0.975.R.`,colour=GDP_USD_PC),alpha=0.1) +
    geom_line(aes(y = `Quantile.0.025.R.`,colour=GDP_USD_PC),alpha=0.7) +
    geom_line(aes(y = `Quantile.0.975.R.`,colour=GDP_USD_PC),alpha=0.7) +
    geom_hline(yintercept=1, linetype="dashed",  color = "black", size=1.05) +
    geom_vline(xintercept=as.Date("2020-03-15"), linetype="dashed",  color = "red", size=1.05) +
    geom_vline(xintercept=as.Date("2020-05-25"), linetype="dashed",  color = "red", size=1.05) +      
    geom_text(aes(x = as.Date("2020-05-25"),y=0.1,label="2020-05-25"),size=1.5,vjust=-1,hjust=1)+
    labs(x= "Date",y="Estimated R") + geom_line(aes(y = Mean.R.),color="black",size=0.1,alpha=0.8) + ylim(c(0.5,4)) +
    ggplot2::theme(
        legend.position="bottom",legend.key.width =  unit(4, "lines")#legend.title=element_blank(),
        )+ 
    facet_wrap(facets=vars(State),ncol=6)+my_theme_13+
    scale_color_gradientn(colors=c("red","royalblue",high="darkblue"),values=c(0,0.4,1),trans="log10",labels=scales::comma)
#estimate_R_plots(estimates,what="R",legend=TRUE)+scale_fill_discrete(name = "Country", labels = EU)
#estimate_R_plots(estimates,what="incid",legend=TRUE)+scale_fill_discrete(name = "Country", labels = EU)
 
```

These transmission curves can be analyzed visually and numerically. Herein we performed hierarchical clustering between the curves by using the $Gap$ between curves as a distance measure. The results of the clustering, by using the complete linkage method, are shown in \@ref(fig:estimations-USA).  

```{r USAgap}
oats_USA_states<-oats_func_loc(incidf=USAs_csv %>% dplyr::filter(as.Date(date)>start_date_USA,as.Date(date)<=end_date_USA), locvar="state")
mi_kable(reshape2::melt(as.matrix(oats_USA_states),varnames=c("State1","State2")),caption="gap between USA states transmission curves")
```

```{r USAclust,fig.height=8,fig.width=8,fig.cap="\\label{fig:USAclust} Hierarchical clustering  for transmission curves of USA states"}

plot(as.dendrogram(hclust(as.dist(oats_USA_states),"complete")),nodePar=list(lab.cex=0.8,pch = c(19), 
                cex = 1),main="Hierarchical clustering. USA states",)
```



## Questions C,E,G. Spain Regional $R_t$ curves, with different windows and different estimators {#Spain}  
```{r}
#source("libraryP.R",encoding="UTF-8")   
```

```{r Spain, echo=FALSE,fig.height=8,fig.width=8}
spain_pop<-read.csv2("SpainCCAA.csv") %>% mutate(Total = as.numeric(Total)) 
spain_pop$CCAA<-plyr::revalue(spain_pop$CCAA,replace=c("Comunitat Valenciana"="C. Valenciana"))

datasources[["Spain_regions"]]@df$ccaa_names<-datasources[["Spain_regions"]]@df$ccaa_iso<-sapply(as.character(datasources[["Spain_regions"]]@df$ccaa_iso),function(x){return(switch(x,"ES-AN"="Andalusia","ES-AR"="Aragon","ES-AS"="Asturias","ES-CM"="Castile-La Mancha","ES-CB"="Cantabria", "ES-CN"="Canarias", "ES-CE"="Ceuta","ES-CL"="Castile and León","ES-EX"="Extremadura", "ES-CT"="Catalonia","ES-VC"="C. Valenciana","ES-GA"="Galicia","ES-IB"="Balearic Islands", "ES-MC"="Murcia","ES-ML"="Melilla","ES-MD"="Madrid","ES-NC"="Navarra","ES-PV"="Basque Country","ES-RI"="La Rioja",x))})
#CCAA<-(subset(msc_csv,FECHA==max(msc_csv$FECHA))  %>% arrange(desc(`num_casos_prueba_pcr`)) %>% slice(1:9))[,"ccaa_names"]
CCAA<-sapply(c("AN","AR","CM","CL","CT","VC","NC","MD","PV"),function(x){return(switch(x,AN="Andalusia",AR="Aragon",CM="Castile-La Mancha",CL="Castile and León",EX="Extremadura", CT="Catalonia",VC="C. Valenciana",GA="Galicia",IB="Balearic Islands",MC="Murcia",MD="Madrid",NC="Navarra",PV="Basque Country",x))})
start_date_Sp<-as.Date("2020/02/25")
end_date_Sp<-as.Date("2021-06-10"  ) 
 
ES_PPC$Region<-plyr::revalue(ES_PPC$Region,c("Basque Country"="Basque Country","Valencia"="C. Valenciana")) #,"Castile and León"="Castilla y León" "Aragon"="Aragón", "Andalusia"="Andalucía" "Catalonia"="Cataluña" "Castile-La Mancha"="Castilla-la Mancha"

comunidades<-list()
for (country in CCAA){
  print(country)
  comunidades[[country]]<-incidf_prepro(incidf=get_cols(df=datasources[["Spain_regions"]]@df,source="Spain_regions",country="Spain",province=country),undetected=0.4,  smooth_method="SMA (centered)", smooth_value=5, ignore=15,warnings="",negatives=dbfs)$df %>% filter(dates>start_date_Sp,dates<end_date_Sp)
}

resultSpain<-comparemodes(comunidades,window=c(3,7),mode="Spain",distributions="Nishiura",TD=TRUE,with_inci=TRUE, with_n_cum = 14, with_rho7 = TRUE,  pop_data = unique(spain_pop), pop_column = "Total", loc_column = "CCAA")
resultSpain$data_to_plot<-resultSpain$data_to_plot %>% dplyr::mutate(Region=Country) %>% merge(ES_PPC[,c("Region","Value")],by="Region",all.x=TRUE,all.y=FALSE) %>% dplyr::rename(GDP_USD_PC=Value) %>% mutate(dates=as.Date(date_end))

resultSpain$incidences<- resultSpain$incidences %>% mutate(Region=Country)

fases<-as.data.frame(matrix(c("Andalucía","2020-05-11","2020-05-25","2020-06-08",
         "Aragón", "2020-05-11","2020-05-25","2020-06-08",
         "Castilla-la Mancha","2020-05-18" ,"2020-06-01","2020-06-08",
         "Castilla y León", "2020-05-25","2020-08-08","2020-06-15",#*
         "Cataluña","2020-05-18","2020-06-01","2020-06-15",#*
         "Extremadura","2020-05-11","2020-05-25","2020-06-08",
         "Galicia","2020-05-11","2020-05-25","2020-06-08",
         "Balearic Islands","2020-05-11","2020-05-25","2020-06-08",
         "Madrid","2020-05-25","2020-06-08",NA,
         "Navarra","2020-05-11","2020-05-25","2020-06-08",
         "Basque Country","2020-05-11","2020-05-25","2020-06-08",
         "C. Valenciana","2020-05-18","2020-06-01","2020-06-12"),ncol=4,byrow=TRUE)) %>% rename(Region=V1,fase_1=V2,fase_2=V3,fase_3=V4) %>% dplyr::filter(Region %in% CCAA)


```

9 Autonomous Communities with large number of cases were selected and epidemic curves after preprocessing (Figure: \@ref(fig:incidenciasSp)) and transmission curves (Figure: \@ref(fig:estimationsSp)) were obtained, by using the current official Health Ministry dataset [@MSCdatos], between `r strftime(start_date_Sp, "%d-%B-%Y")` and `r max(resultSpain$incidences$dates)`. Preprocessing parameters include: centered SMA smoothing, 5 days smooth span, and +40% increase in daily incidences to account for undetected cases (due to the possible underestimation of cases in the initial period). Multiple $si$ distributions obtained with the Nishiura et al dataset were used. Regional GDP per capita (US dollars, current prices, current purchasing power parity) data from OECD for 2018 (Spain) [@OECD] was used to color the transmission curves. 

```{r incidenciasSp, fig.cap="\\label{fig:incidenciasSp} COVID-19 incidence in several Spanish Autonomous Communities. Highlighted dates: 2020-03-08 (8M), 2020-03-14 (State of Alarm), 2020-03-28 (Economic stop), 2020-04-13 (Partial economic restart), 2020-05-04 (Return to 'normal', phase 0), 2020-06-21 (End of the state of Alarm), 2020-10-09 (State of Alarm in Madrid), 2020-10-25 (State of Alarm in the whole country), 2021-05-09 (End of the state of Alarm)", echo=FALSE, fig.height=6, fig.width=8}
add_weekdays(ggplot(resultSpain$incidences %>% filter(Incidences>1) %>% tidyr::drop_na(), aes(x = dates, y = Incidences, group = factor(Region)))  ,mindate=min(resultSpain$incidences$dates),maxdate=max(resultSpain$incidences$dates)) +
    geom_line(aes(y = Incidences,color=Region),size=1.1) +
    geom_line(aes(y = Incidences,color=Region),size=1.1,alpha=0.8) +
    geom_vline(xintercept=as.Date("2020-03-08"), linetype="dotted",  color = "black", size=1.05) +
    geom_vline(xintercept=as.Date("2020-03-14"), linetype="solid",  color = "darkred", size=1.2) +
    geom_vline(xintercept=as.Date("2020-03-28"), linetype="dotdash",  color = "darkred", size=1.05) +
    geom_vline(xintercept=as.Date("2020-04-13"), linetype="dotdash",  color = "darkblue", size=1.05) +
    geom_vline(xintercept=as.Date("2020-05-04"), linetype="dotdash",  color = "black", size=1.05) + 
    geom_vline(xintercept=as.Date("2020-06-21"), linetype="solid",  color = "darkblue", size=1.2) + 
    geom_vline(xintercept=as.Date("2020-10-09"), linetype="dotdash",  color = "darkred", size=1.05) +
    geom_vline(xintercept=as.Date("2020-10-25"), linetype="solid",  color = "darkred", size=1.2) +
    geom_vline(xintercept=as.Date("2021-05-09"), linetype="solid",  color = "darkblue", size=1.05) +
    #geom_vline(data=fases,mapping=aes(xintercept=as.Date(fase_1)), linetype="dashed",  color = "midnightblue", size=0.65) +
    #geom_vline(data=fases,mapping=aes(xintercept=as.Date(fase_2)), linetype="dashed",  color = "midnightblue", size=0.65) +
    #geom_vline(data=fases,mapping=aes(xintercept=as.Date(fase_3)), linetype="dashed",  color = "midnightblue", size=0.65) +
     #scale_fill_discrete(name = "Country", labels = EU) +
    labs(x= "Date",y="Daily incidence") + my_theme + scale_y_continuous(trans='log10') + scale_x_date(date_breaks = "4 month",date_labels = "%b") +
    scale_colour_brewer(  type = "qual", palette = "Set1", direction = 1, aesthetics = "colour")

```


```{r estimationsSp, fig.cap="\\label{fig:estimationsSp} R_t estimates for several Spanish Autonomous Communities.  Highlighted dates: 2020-03-08 (8M), 2020-03-14 (State of Alarm), 2020-03-28 (Economic stop), 2020-04-13 (Partial economic restart), 2020-05-04 (Return to 'normal', phase 0), phases 1 and 2, 2020-06-21 (End of the state of Alarm), 2020-10-09 (State of Alarm in Madrid), 2020-10-25 (State of Alarm in the whole country), 2021-05-09 (End of the state of Alarm)",echo=FALSE,fig.height=12,fig.width=11}

#(incidences_Sp %>% group_by(Community) %>% summarize (N=sum(Incidences)) %>% dplyr::filter(N>7000))$Community),]
ggplot(resultSpain$data_to_plot %>% filter(Method=="Cori, w= 7"), aes(x = date_end, y = as.numeric(`Mean.R.`),color=GDP_USD_PC)) + 
    geom_line(aes(y = Mean.R.,color=GDP_USD_PC),size=1.1) +
    geom_ribbon(aes(ymin = `Quantile.0.025.R.`, ymax = `Quantile.0.975.R.`, fill = "95%CrI",color=GDP_USD_PC),alpha=0.1) +
    geom_line(aes(y = `Quantile.0.025.R.`,color=GDP_USD_PC),linetype=2,alpha=0.7) +
    geom_line(aes(y = `Quantile.0.975.R.`,color=GDP_USD_PC),linetype=2,alpha=0.7) +
    geom_line(aes(y = Mean.R.,color=GDP_USD_PC),size=1.2,alpha=0.8) +
    geom_hline(yintercept=1, linetype="dashed",  color = "black", size=1.05) +
    geom_vline(xintercept=as.Date("2020-03-08"), linetype="dotted",  color = "black", size=1.05) +
    geom_vline(xintercept=as.Date("2020-03-14"), linetype="solid",  color = "darkred", size=1.2) +
    geom_vline(xintercept=as.Date("2020-03-28"), linetype="dotdash",  color = "darkred", size=1.05) + 
    geom_vline(xintercept=as.Date("2020-04-13"), linetype="dotdash",  color = "darkblue", size=1.05) +
    geom_vline(xintercept=as.Date("2020-05-02"), linetype="dotdash",  color = "black", size=1.05) +
    geom_vline(xintercept=as.Date("2020-06-21"), linetype="solid",  color = "darkblue", size=1.2) +
    geom_vline(xintercept=as.Date("2020-10-09"), linetype="dotdash",  color = "darkred", size=1.05) +
    geom_vline(xintercept=as.Date("2020-10-25"), linetype="solid",  color = "darkred", size=1.2) +
    geom_vline(xintercept=as.Date("2021-05-09"), linetype="solid",  color = "darkblue", size=1.05) +
    geom_vline(data=fases,mapping=aes(xintercept=as.Date(fase_1)), linetype="dashed",  color = "midnightblue", size=1.05) +
    geom_vline(data=fases,mapping=aes(xintercept=as.Date(fase_2)), linetype="dashed",  color = "mediumvioletred", size=1.05) +
    geom_vline(data=fases,mapping=aes(xintercept=as.Date(fase_3)), linetype="dashed",  color = "midnightblue", size=1.05) +
    labs(x= "Date",y="Estimated R") + geom_line(aes(y = Mean.R.),color="black",size=0.1,alpha=0.8) + ylim(c(0,6)) +
    my_theme+theme_bottom_legend+ theme_grid_light +
  scale_colour_gradientn(colours=c("red","blue"))+facet_wrap(facets=vars(Region),ncol=3)+lims(y=c(0,4)) + scale_x_date(date_breaks = "4 month",date_labels = "%b")
#estimate_R_plots(estimates,what="R",legend=TRUE)+scale_fill_discrete(name = "Country", labels = EU)
#estimate_R_plots(estimates,what="incid",legend=TRUE)+scale_fill_discrete(name = "Country", labels = EU)

```
Uncontrolled exponential dissemination took place early in March; particularly earlier in Madrid, the Basque Country and Catalonia, some of the most densely populated regions and important economic centers with the 1st, 2nd and 4th highest GDP per capita in the country. On the other hand, the epidemic peak took place later in Castilla-la Mancha. In the week after the 8th of March the $R_t$ started to decline, following the implementation of several contact-prevention measures. The State of Alarm declaration on 14 March was associated with a fast and sharp decline in the virus transmission reaching $R_t$<1 before the end of April, effectively heralding adequate epidemic control. Although the exponential increase did not occur at the same time or pace, the decrease was quite similar between regions. 

The State of Alarm ended on 21st June 2020, after several weeks of gradual reopening with controlled transmission. After this several regions - not necessarily the wealthier and more densely-populated ones -  exhibited a growth in the number of cases preceded by increased transmission (Aragón[@AragonJunio], Andalucía[@AndaluciaJunio]...), eventually affecting Madrid and Catalonia.   

In the case of Spain, initial **containment** efforts (such as the quarantine of an hospital) were successful[@girones], but soon it was apparent that the uncontrolled and exponential community transmission was taking place, as evidenced in both the epidemic curves and the $R_t$ curves. In the 9th of March **reinforced containment** measures were initiated (halting in-person education, workplace contacts avoiding, etc.) for areas with significant community transmission (which were the region of Madrid and the cities of Vitoria and Labastida)[@RPrensa9M]; transmission started to decrease as education institutions and public places were gradually closed in the different regions. The Government decreed a State of Alarm on the 14th of March, switching to a **supression strategy** imposing a nation-wide lockdown involving commercial places closures, stay-at-home regulations and a ban on internal travels. Thus a consistently decreasing $R_t$ and the effective control of the disease it hallmarks was reached[@Kassem2020], and Spain managed to successfully 'bend the curve'. The reproductive ratio has been shown to be highly dependent on mobility [@Arenas2020][@Bergman2020]. 

$CIR_{14}$ and OI ratio are shown in \@ref(fig:SpainOIcurves), calculated with 2019 population data from the [2019 Spanish Municipal Register, from the National Statistics Institute](https://www.ine.es/jaxiT3/Datos.htm?t=2853) (accessed 27-10-2020). In the second wave $R_t$ surges preceded prevalence indicator surges (Madrid, July-August; C. Valenciana, July; Aragón, July; Castile and León, July and August). 

```{r SpainOIcurves, fig.cap="\\label{SpainOIcurves} $CIR_{14}$ and OI ratio for several Spanish Autonomous Communities(2020-2021). ",echo=FALSE,fig.height=7,fig.width=6}
resultSpain$OA<-resultSpain$OA %>% dplyr::mutate(Indic="Ov. Infectivity ratio") 
resultSpain$OAc<-rbind(resultSpain$OA %>% dplyr::filter(complete.cases(resultSpain$OA$OA_ratio)) %>% mutate (OA_ratio=OA_ratio),
                        (resultSpain$n_cum %>% dplyr::filter(complete.cases(resultSpain$n_cum$Ind)) %>%
                           mutate(OA_ratio=Ind,Indic="14 cum inc ratio",`Overall.Infectivity`=NA) %>%
                           tidyr::crossing(distr=unique(resultSpain$OA$distr))) [,colnames(resultSpain$OA)])

 
resultSpain$OAc<-resultSpain$OAc %>% rename(Location=Country) %>% mutate (dates=as.Date(dates))
 
add_weekdays(ggplot(resultSpain$OAc[,], aes(x = dates, y = as.numeric(`OA_ratio`), group=Indic)),mindate=min(resultSpain$OAc$dates),maxdate=max(resultSpain$OAc$dates)) +
    geom_line(size=1.3,aes(colour=Indic)) + 
    #geom_line(aes(y = Mean.R.,color=Regions),size=1.3,alpha=0.8) +
    #ggtitle("Estimated R")+scale_fill_discrete(name = "Country", labels = EU) +
    labs(x= "Date",y="Value")  +  #ylim(c(0.2,4.8)) + geom_line(aes(y = Mean.R.),color="black",size=0.1,alpha=0.8) +
    my_theme_12+theme(strip.text.y = element_text(size=10),
                      axis.title.x=element_blank(),#legend.position="bottom",
                      axis.text.y = element_text(size=11,angle = 0)) +
  scale_colour_brewer(type = "qual", palette = "Set1", direction = 1, aesthetics = "colour") + facet_grid(rows=vars(Location),cols=vars(distr),scales="free_y") + scale_x_date(date_breaks = "4 month",date_labels = "%b") +
  geom_rect(mapping=aes(xmin=min(resultSpain$OAc$dates),xmax=min(resultSpain$OAc$dates),ymin=0,ymax=0,fill="Weekdays"),alpha=0.3)
 
```

As a counterpart for the weekly estimates for Spanish regions, three-day $R_t$ estimates are obtained and displayed here (fig \@ref(fig:Spain-d)).  

```{r Spain-d, echo=FALSE,fig.height=12,fig.width=11,fig.cap="\\label{estimations-Sp-d}$R_t$ estimates for several Spanish Autonomous Communities. Three-day estimation windows. Highlighted dates: 2020-03-08 (8M), 2020-03-14 (State of Alarm), 2020-03-28 (Economic stop), 2020-04-13 (Partial economic restart), 2020-05-04 (Return to 'normal', phase 0),phases 1 and 2, 2020-06-21 (End of the state of Alarm), 2020-10-09 (State of Alarm in Madrid), 2020-10-25 (State of Alarm in the whole country), 2021-05-09 (End of the state of Alarm)",echo=FALSE,}
#msc_csv<-subset(read.csv(MSC_path),(FECHA!="") & (!(is.na(`PCR.`))))
#msc_csv$FECHA<-as.Date(msc_csv$FECHA,"%d/%m/%Y")
#msc_csv$CCAA<-sapply(levels(msc_csv$CCAA)[msc_csv$CCAA],function(x){return(switch(x,AN="Andalucía",AR="Aragón",CM="Castilla-la Mancha",CL="Castilla y León", CT="Cataluña",VC="Valencia",GA="Galicia",MD="Madrid",PV="País Vasco",x))})
#CCAA<-(subset(msc_csv,FECHA==max(msc_csv$FECHA)) %>% arrange(desc(`PCR.`)) %>% arrange(desc(`PCR.`)) %>% slice(1:9))[,"CCAA"] 
ggplot(resultSpain$data_to_plot %>% filter(Method=="Cori, w= 3"), aes(x = date_end, y = as.numeric(`Mean.R.`),color=GDP_USD_PC)) + 
    geom_line(aes(y = Mean.R.,color=GDP_USD_PC),size=1.1) +
    geom_ribbon(aes(ymin = `Quantile.0.025.R.`, ymax = `Quantile.0.975.R.`, fill = "95%CrI",color=GDP_USD_PC),alpha=0.1) +
    geom_line(aes(y = `Quantile.0.025.R.`,color=GDP_USD_PC),linetype=2,alpha=0.7) +
    geom_line(aes(y = `Quantile.0.975.R.`,color=GDP_USD_PC),linetype=2,alpha=0.7) +
    geom_line(aes(y = Mean.R.,color=GDP_USD_PC),size=1.2,alpha=0.8) +
    geom_hline(yintercept=1, linetype="dashed",  color = "black", size=1.05) +
    geom_vline(xintercept=as.Date("2020-03-08"), linetype="dotted",  color = "black", size=1.05) +
    geom_vline(xintercept=as.Date("2020-03-14"), linetype="solid",  color = "darkred", size=1.05) +
    geom_vline(xintercept=as.Date("2020-03-28"), linetype="dotdash",  color = "darkred", size=1.05) +
    geom_vline(xintercept=as.Date("2020-04-13"), linetype="dotdash",  color = "darkblue", size=1.05) + 
    geom_vline(xintercept=as.Date("2020-05-02"), linetype="dotdash",  color = "black", size=1.05) +
    geom_vline(xintercept=as.Date("2020-06-21"), linetype="solid",  color = "darkblue", size=1.2) +
    geom_vline(xintercept=as.Date("2020-10-09"), linetype="dotdash",  color = "darkred", size=1.05) +
    geom_vline(xintercept=as.Date("2020-10-25"), linetype="solid",  color = "darkred", size=1.2) +
    geom_vline(xintercept=as.Date("2021-05-09"), linetype="solid",  color = "darkblue", size=1.05) +
      geom_vline(data=fases,mapping=aes(xintercept=as.Date(fase_1)), linetype="dashed",  color = "midnightblue", size=1.05) +
    geom_vline(data=fases,mapping=aes(xintercept=as.Date(fase_2)), linetype="dashed",  color = "mediumvioletred", size=1.05) +
    labs(x= "Date",y="Estimated R") + geom_line(aes(y = Mean.R.),color="black",size=0.1,alpha=0.8) + ylim(c(0,6)) +
    my_theme+theme_bottom_legend+ scale_x_date(date_breaks = "4 month",date_labels = "%b") +
  scale_colour_gradientn(colours=c("red","blue"))+facet_wrap(vars(Region))+lims(y=c(0,5))

```

Given the significant weekday bias and the clinically relevant differences with 7-day windows $R_t$ estimates, three day windows are not recommended.  

Finally, hierarchical clustering analysis between COVID-19 transmission curves of Spanish Autonomous Communities has been performed 

```{r Spaingap}

oats_Spain_regions<-oats_func_loc(incidf=datasources[["Spain_regions"]]@df %>% dplyr::filter(as.Date(fecha)>start_date_USA,as.Date(fecha)<=end_date_USA), locvar="ccaa_names",get_data_method=function(df,i){return(df[df[,"ccaa_names"]==i,] %>% mutate (dates=as.Date(fecha,"%Y-%m-%d"),I=num_casos))})
mi_kable(triangulardf(oats_USA_states),caption="Mean daily GAP between USA states transmission curves")

```

```{r Spainclust,fig.height=8,fig.width=8,fig.cap="\\label{fig:Spainclust} Hierarchical clustering for transmission curves of Spain regions"}

plot(as.dendrogram(hclust(as.dist(oats_Spain_regions),"complete")),nodePar=list(lab.cex=1,pch = c(NA,19), 
                cex = 1),main="Spain Autonomous Communities")
```

## Question E. Peru: The regional estimates of a developing country{#PeruRegions}

```{r peru}
Peru<-datasources[["Peru"]]@getData(datasources[["Peru"]])
regiones_peruanas<-list()
start_date_Peru<-as.Date("2020/03/15")
end_date_Peru<-as.Date("2021-06-10"  )

Peru$region<-plyr::revalue(Peru$region,c("Ancash"="Áncash","Apurimac"="Apurímac","Lima Metropolitana"="Lima")) 
Peru_PPC$Region<-plyr::revalue(Peru_PPC$Region, c("Amazonas (PE)"="Amazonas", "Madre de dios"="Madre de Dios","Prov. const. del Callao"="Callao","San Martin"="San Martín"))

for (country in as.character(levels(Peru$region))){
  if (country!="Lima Metropolitana"){
    regiones_peruanas[[country]]<-incidf_prepro(incidf=get_cols(df=Peru,source="Peru",country="Peru",province=country) %>% dplyr::filter(dates>start_date_Peru,dates<end_date_Peru),undetected=0.4,  smooth_method="SMA (centered)", smooth_value=7, ignore=15,warnings="",negatives=dbfs)$df
  }
}


moderesultsPeru<-comparemodes(regiones_peruanas,mode="Peruvian regions",window = 7,TD=FALSE,with_inci=TRUE,distributions = "Du")


moderesultsPeru$data_to_plot <- moderesultsPeru$data_to_plot %>% rename(Region=Country) %>%
  merge(Peru_PPC[,c("Region","Value")],by="Region") %>% rename(GDP_USD_PC=Value)

```

Using the MINSA incidence data between `r strftime(start_date_Peru,"%d-%B-%Y")` and `r strftime(end_date_Peru,"%d-%B-%Y")`, compiled by JM Castagnetto[@Castagnetto], the regional epidemic curves (figure (\@ref(fig:incidencias-Peru))) and transmission curves (figure \@ref(fig:estimations-Peru)) of Perú have been obtained. Preprocessing parameters include: SMA smoothing, 7 days as smooth span, +40% proportion of undetected cases. In the transmission curve the states have been colored according to their GDP per capita (purchase power parity, current prices) [@OECD]. (Metropolitan Lima data is assigned to Lima.) 

```{r incidencias-Peru, fig.cap="\\label{fig:incidencias-Peru} COVID-19 incidence in several Peruvian regions",echo=FALSE,fig.height=9,fig.width=11}
moderesultsPeru$incidences$graph<-floor((as.numeric(factor(moderesultsPeru$incidences$Country))-1)/9) 
ggarrange(
add_weekdays(ggplot(moderesultsPeru$incidences[moderesultsPeru$incidences$Incidences>1 & moderesultsPeru$incidences$graph==0,] %>% tidyr::drop_na(), aes(x = dates, y = Incidences ,group=Country)),mindate=min(moderesultsPeru$incidences$dates),maxdate=max(moderesultsPeru$incidences$dates)) +
    geom_line(aes(y = Incidences,colour=Country),size=1.1) +
    #geom_line(aes(y = Incidences),colour="black",size=0.6) +
    labs(x= "Date",y="Daily incidence") + ggplot2::theme(
            legend.position="bottom",legend.title=element_blank(),legend.text = element_text(size=13),
            axis.text.x = element_text(size = 13,angle=45),axis.text.y = element_text(size = 14),
              axis.title = element_blank())  + scale_y_continuous(trans='log10') +
    scale_colour_brewer(  type = "qual", palette = "Paired", direction = 1, aesthetics = "colour")+
  guides(col=guide_legend(nrow=5)),
add_weekdays(ggplot(moderesultsPeru$incidences[moderesultsPeru$incidences$Incidences>1 & moderesultsPeru$incidences$graph==1,] %>% tidyr::drop_na(), aes(x = dates, y = Incidences ,group=Country)),mindate=min(moderesultsPeru$incidences$dates),maxdate=max(moderesultsPeru$incidences$dates)) +
    geom_line(aes(y = Incidences,colour=Country),size=1) +
    labs(x= "Date",y="Daily incidence") + ggplot2::theme(
            legend.position="bottom",legend.title=element_blank(),legend.text = element_text(size=13),
            axis.text.x = element_text(size = 13,angle=45),axis.text.y = element_text(size = 14),
              axis.title = element_blank()) + scale_y_continuous(trans='log10') +
    scale_colour_brewer(  type = "qual", palette = "Paired", direction = 1, aesthetics = "colour")+
  guides(col=guide_legend(nrow=5)),
add_weekdays(ggplot(moderesultsPeru$incidences[moderesultsPeru$incidences$Incidences>1 & moderesultsPeru$incidences$graph==2,] %>% tidyr::drop_na(), aes(x = dates, y = Incidences ,group=Country)),mindate=min(moderesultsPeru$incidences$dates),maxdate=max(moderesultsPeru$incidences$dates)) +
    geom_line(aes(y = Incidences,colour=Country),size=1) +
    labs(x= "Date",y="Daily incidence") + ggplot2::theme(
            legend.position="bottom",legend.title=element_blank(),legend.text = element_text(size=13),
            axis.text.x = element_text(size = 13,angle=45),axis.text.y = element_text(size = 14),
              axis.title = element_blank()) + scale_y_continuous(trans='log10') +
    scale_colour_brewer(  type = "qual", palette = "Paired", direction = 1, aesthetics = "colour")+ guides(col=guide_legend(nrow=5)),ncol=3,nrow=1)

```

```{r estimations-Peru, fig.cap="\\label{estimations-Peru}$R_t$ estimates for Peruvian regions",echo=FALSE,fig.height=12,fig.width=11}
ggplot(moderesultsPeru$data_to_plot, aes(x = date_end, y = as.numeric(`Mean.R.`,colour=GDP_USD_PC))) + 
    geom_line(aes(y = Mean.R.,colour=GDP_USD_PC),size=1.15) +
    geom_ribbon(aes(ymin = `Quantile.0.025.R.`, ymax = `Quantile.0.975.R.`),alpha=0.1) +
    geom_line(aes(y = `Quantile.0.025.R.`,colour=GDP_USD_PC),linetype=2,alpha=0.7) +
    geom_line(aes(y = `Quantile.0.975.R.`,colour=GDP_USD_PC),linetype=2,alpha=0.7) +
    geom_hline(yintercept=1, linetype="dashed",  color = "black", size=1.05) +
    labs(x= "Date",y="Estimated R") + geom_line(aes(y = Mean.R.),color="black",size=0.1,alpha=0.8) + ylim(c(0.5,4)) +
    ggplot2::theme(
      legend.position="bottom",
                strip.text = element_text(size=12),
                axis.title.x = element_text(size = 12), axis.text.x = element_text(size = 10,angle=90),
                axis.title.y = element_text(size = 12), axis.text.y = element_text(size = 10,angle=90))+ 
    facet_wrap(facets=vars(Region),ncol=5)+theme_bottom_legend+
    scale_colour_gradientn(colours=c("yellow","darkblue"))
```

When compared to the regions in developed countries (Spain, Belgium), the regions in Perú show a marked pattern of increased variability (more peaks and valleys, maybe due to smaller incidences or smaller region sizes) and more difficulty reaching control; similarly to the infection curves in other developing countries. Many regions exhibit peaks, but not all of them had the same impact on the incidence: The Moquegua and Pasco peaks reflected an increase from around 5 reported cases per day to 20 reported cases per day; the Piura peak was caused by an increase from less than 200 cases per day to 500 cases per day. This information should be interpreted with caution; the daily reported incidence could be influenced by testing capacity. The subtle pattern seen in USA states (wealthier states have more cases but better epidemic control) is not clearly observed here. 

Overall, both regions in USA and regions in Perú follow a similar pattern, and the GDP per capita was not associated or mildly associated to differences the transmission curves. Also, in regions with smaller GDP per capita the epidemic apparently started later.


Hierarchical clustering analysis has also been performed for the Peru regional data, with the previously defined methodology (Fig: \@ref(fig:estimationscsubel)).  

```{r Perugap}

smallPeru<-Peru[,c("region","date","confirmed")]

for (fecha in unique(smallPeru$date))
{
  L<-LM<-LR<-NA
  L<-as.numeric(smallPeru[(smallPeru$date==fecha) & (smallPeru$region=="Lima"),"confirmed"])
  if (length(L)==0) L<-NA
  LM<-as.numeric(smallPeru[(smallPeru$date==fecha) & (smallPeru$region=="Lima Metropolitana"),"confirmed"])
  if (length(LM)==0) LM<-NA
  LR<-as.numeric(smallPeru[(smallPeru$date==fecha) & (smallPeru$region=="Lima Región"),"confirmed"])
  if (length(LR)==0) LR<-NA
  if (nrow(smallPeru[(smallPeru$date==fecha) & (smallPeru$region=="Lima"),])==0){
    smallPeru[nrow(smallPeru)+1,]<-c("Lima",fecha,if (is.na(LM) & is.na(LR) & is.na(L)) NA else sum(LM,LR,L,na.rm=TRUE))
    }
  else{
    smallPeru[(smallPeru$date==fecha) & (smallPeru$region=="Lima"),"confirmed"]<-if (is.na(LM) & is.na(LR) & is.na(L)) NA else sum(LM,LR,L,na.rm=TRUE)
  }
}

oats_Peru_regions<-oats_func_loc(incidf=smallPeru %>% dplyr::filter(as.Date(date)>start_date_Peru,as.Date(date)<=end_date_Peru), locvar="region",get_data_method=function(df,i){return(fdf_to_inci(df[df[,"region"]==i,] %>% mutate (dates=as.Date(date,"%Y-%m-%d"),Cum=as.numeric(confirmed))))},exclude_regions = c("Lima Metropolitana","Lima Región","* All *"))
mi_kable(triangulardf(oats_Peru_regions),caption="Mean daily GAP between Peru regional transmission curves")

```

```{r Peruclust,fig.height=6,fig.cap="\\label{fig:Peruclust} Hierarchical clustering  for transmission curves of Peru regions"}

plot(as.dendrogram(hclust(as.dist(oats_Peru_regions),"complete")),nodePar=list(lab.cex=1,pch = c(NA,19),  
                cex = 1),main="Peru regions")
```



## Question G: Implications for reopening (Germany){#Germany}

```{r GER-dates}
GerOutBreak_start<-as.Date("2020-03-20")
GerOutBreak_end<-as.Date("2020-12-10"  )
```

In Germany, in late June, after the reopening, several cases took place in clusters and the authorities managed them with a containment policy: In the middle-late of June an outbreak took place in an apartment building in Berlin[@Berlin], requiring quarantine measures. On the 24th of June the districts of Warendorf and Gütersloh in the state of North Rhine-Westphalia were put in lockdown following an outbreak in a meat processing plan[@Warendorf]. The purpose of section is to evaluate whether these outbreaks were reflected in the $R_t$ of affected areas and whether non-affected areas showed any $R_t$ impact. By using the [Germany COVID-19 dataset](https://github.com/jgehrcke/covid-19-germany-gae) compiled by J Gehrcke from the information provided by the Robert-Köch-Institute[@Germany], $R_t$ estimates from `r GerOutBreak_start` to `r GerOutBreak_end` have been obtained, for the districts of Gütersloh, Warendorf, the state of Westphalen, three "randomly" selected districts (Eisenach, Leipzig and Weimar), the state of Berlin and the state of Brandenburg.  The preprocessing parameters include centerd SMA smoothing with a smoothing span of 4. Figure \@ref(fig:Ger-rebound) shows the epidemic curves, figure \@ref(fig:GermanyRr) shows the transmission curves obtained the date before these measures were implemented and figure \@ref(fig:GermanyR) shows the transmission curves obtained several weeks later. 

```{r Ger-rebound,fig.cap="\\label{fig:Ger-rebound}Epidemic curves of Germany subnational divisions. Notice the weekday-weekend bias",echo=FALSE,fig.height=6.5,fig.width=7}
Ger<-datasources[["GerAgs"]]@getData(datasources[["GerAgs"]])

firstGer<-Ger %>% filter(as.Date(Ger$dates)<as.Date("2020-06-24"))
GerOutBreak<-comparemodes(
list(`Gütersloh`=incidf_prepro(incidf=get_cols(df=Ger,source="GerAgs",province = "LK Gütersloh"),undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>as.Date(GerOutBreak_start),dates<as.Date(GerOutBreak_end)),
     Warendorf=incidf_prepro(get_cols(df=Ger,source="GerAgs",province = "LK Warendorf"),undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>as.Date(GerOutBreak_start),dates<as.Date(GerOutBreak_end)),
     Westphalen=incidf_prepro(get_cols(df=Ger,source="GerAgs",country = "Nordrhein-Westfalen"), undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>as.Date(GerOutBreak_start),dates<as.Date(GerOutBreak_end)),
     Germany=incidf_prepro(get_cols(df=Ger,source="GerAgs"), undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>as.Date(GerOutBreak_start),dates<as.Date(GerOutBreak_end)),
     Eisenach=incidf_prepro(get_cols(df=Ger,source="GerAgs",province = "SK Leipzig"),undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>as.Date(GerOutBreak_start),dates<as.Date(GerOutBreak_end)),
     Leipzig=incidf_prepro(get_cols(df=Ger,source="GerAgs",province = "LK Leipzig"),undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>as.Date(GerOutBreak_start),dates<as.Date(GerOutBreak_end)),
     Weimar=incidf_prepro(get_cols(df=Ger,source="GerAgs",province = "SK Weimar"),undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=8,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>as.Date(GerOutBreak_start),dates<as.Date(GerOutBreak_end)),
     Berlin=incidf_prepro(get_cols(df=Ger,source="GerAgs",country = "Berlin"),undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>as.Date(GerOutBreak_start),dates<as.Date(GerOutBreak_end)),
     Brandenburg=incidf_prepro(get_cols(df=Ger,source="GerAgs",country = "Brandenburg"),undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>as.Date(GerOutBreak_start),dates<as.Date(GerOutBreak_end))
     ),
mode="Germany",window = c(3,7),TD=FALSE,with_inci=TRUE,distributions = "Du", with_n_cum=14, with_rho7 = TRUE)

GerOutBreak1<-comparemodes(
list(`Gütersloh`=incidf_prepro(incidf=get_cols(df=firstGer,source="GerAgs",province = "LK Gütersloh"),undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>as.Date(GerOutBreak_start),dates<as.Date(GerOutBreak_end)),
     Warendorf=incidf_prepro(get_cols(df=firstGer,source="GerAgs",province = "LK Warendorf"),undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>as.Date(GerOutBreak_start),dates<as.Date(GerOutBreak_end)),
     Westphalen=incidf_prepro(get_cols(df=firstGer,source="GerAgs",country = "Nordrhein-Westfalen"), undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>as.Date(GerOutBreak_start),dates<as.Date(GerOutBreak_end)),
     Germany=incidf_prepro(get_cols(df=firstGer,source="GerAgs"), undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>as.Date(GerOutBreak_start),dates<as.Date(GerOutBreak_end)),
     Eisenach=incidf_prepro(get_cols(df=firstGer,source="GerAgs",province = "SK Leipzig"),undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>as.Date(GerOutBreak_start),dates<as.Date(GerOutBreak_end)),
     Leipzig=incidf_prepro(get_cols(df=firstGer,source="GerAgs",province = "LK Leipzig"),undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>as.Date(GerOutBreak_start),dates<as.Date(GerOutBreak_end)),
     Weimar=incidf_prepro(get_cols(df=firstGer,source="GerAgs",province = "SK Weimar"),undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=8,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>as.Date(GerOutBreak_start),dates<as.Date(GerOutBreak_end)),
     Berlin=incidf_prepro(get_cols(df=firstGer,source="GerAgs",country = "Berlin"),undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>as.Date(GerOutBreak_start),dates<as.Date(GerOutBreak_end)),
     Brandenburg=incidf_prepro(get_cols(df=firstGer,source="GerAgs",country = "Brandenburg"),undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>as.Date(GerOutBreak_start),dates<as.Date(GerOutBreak_end))
     ),
mode="Germany",window = c(3,7),TD=FALSE,with_inci=TRUE,distributions = "Du")

GerOutBreak$incidences$dates<-as.Date(GerOutBreak$incidences$dates)
GerOutBreak$incidences$Location<-GerOutBreak$incidences$Country

GerOutBreak1$incidences$dates<-as.Date(GerOutBreak1$incidences$dates)
GerOutBreak1$incidences$Location<-GerOutBreak1$incidences$Country

add_weekdays(ggplot(GerOutBreak$incidences[GerOutBreak$incidences$Incidences>0 & complete.cases(GerOutBreak$incidences),], aes(x = dates, y = Incidences, group = factor(Location))), mindate=min(GerOutBreak$incidences$dates),maxdate=max(GerOutBreak$incidences$dates)) +
  geom_line(aes(y = Incidences,color=Location),size=1.4,alpha=0.8) +
    ggtitle("Germany")+ 
    labs(x=element_blank(),y="Daily incidence") + my_theme + 
  scale_y_continuous(trans='log10',limits=c(1,100000))+ 
    geom_vline(xintercept=as.Date("2020-06-24"),size=1)+
    geom_text(aes(x = as.Date("2020-06-24"),y=0.1,label="2020-06-24"),size=2,vjust=-1,hjust=1)+
   guides(colour = guide_legend(override.aes = list(alpha = 1))) + scale_color_brewer(type="Qual",palette="Set1")

```

We can observe the scale of the epidemic is one-two orders of magnitude higher in states than in districts; the incidence in districts might be too low to obtain $R_t$ estimates.  

```{r GermanyR, fig.cap="\\label{fig:GermanyR}Transmission curves of Germany",echo=FALSE,fig.height=11,fig.width=11,eval=TRUE}
GerOutBreak$data_to_plot<-GerOutBreak$data_to_plot %>% rename(Location=Country,dates=date_end) %>% mutate (dates=as.Date(dates))

add_weekdays(ggplot(GerOutBreak$data_to_plot[complete.cases(GerOutBreak$data_to_plot),], aes(x = dates, y = as.numeric(`Mean.R.`), group = as.factor(Method))),
             mindate=min(GerOutBreak$data_to_plot$dates),maxdate=max(GerOutBreak$data_to_plot$dates)) +
    geom_line(aes(y = Mean.R.,color=Method),size=1.3) +
    geom_ribbon(aes(ymin = `Quantile.0.025.R.`, ymax = `Quantile.0.975.R.`,color=Method),alpha=0.05) +
    geom_line(aes(y = `Quantile.0.025.R.`,color=Method),linetype=2,alpha=0.4) +
    geom_line(aes(y = `Quantile.0.975.R.`,color=Method),linetype=2,alpha=0.4) +
    #geom_line(aes(y = Mean.R.,color=Regions),size=1.3,alpha=0.8) +
    geom_hline(yintercept=1, linetype="dashed",  color = "black", size=1.05) +
    #ggtitle("Estimated R")+scale_fill_discrete(name = "Country", labels = EU) +
    labs(x= "Date",y="Estimated R")  +  #ylim(c(0.2,4.8)) + geom_line(aes(y = Mean.R.),color="black",size=0.1,alpha=0.8) +
      geom_vline(xintercept=as.Date("2020-06-24"),size=1)+
    geom_text(aes(x = as.Date("2020-06-24"),y=0.1,label="2020-06-24"),size=2,vjust=-1,hjust=1)+
    my_theme+theme(axis.title.x=element_blank(),legend.position="bottom")+
  scale_colour_brewer(type = "qual", palette = "Set1", direction = 1, aesthetics = "colour") + facet_wrap(facets=vars(Location),scales="free_y") + 
  geom_rect(mapping=aes(xmin=min(GerOutBreak$data_to_plot$dates),xmax=min(GerOutBreak$data_to_plot$dates),ymin=0,ymax=0,fill="Weekdays"),alpha=0.3)
```

```{r GermanyRr, fig.cap="\\label{fig:GermanyRr}Transmission curves of Germany estimated one date before measures were implemented",echo=FALSE,fig.height=11,fig.width=11,eval=TRUE}
GerOutBreak1$data_to_plot<-GerOutBreak1$data_to_plot %>% rename(Location=Country,dates=date_end) %>% mutate (dates=as.Date(dates))

add_weekdays(ggplot(GerOutBreak1$data_to_plot[complete.cases(GerOutBreak1$data_to_plot),], aes(x = dates, y = as.numeric(`Mean.R.`), group = as.factor(Method))),
             mindate=min(GerOutBreak1$data_to_plot$dates),maxdate=max(GerOutBreak1$data_to_plot$dates)) +
    geom_line(aes(y = Mean.R.,color=Method),size=1.3) +
    geom_ribbon(aes(ymin = `Quantile.0.025.R.`, ymax = `Quantile.0.975.R.`,color=Method),alpha=0.05) +
    geom_line(aes(y = `Quantile.0.025.R.`,color=Method),linetype=2,alpha=0.4) +
    geom_line(aes(y = `Quantile.0.975.R.`,color=Method),linetype=2,alpha=0.4) +
    #geom_line(aes(y = Mean.R.,color=Regions),size=1.3,alpha=0.8) +
    geom_hline(yintercept=1, linetype="dashed",  color = "black", size=1.05) +
    #ggtitle("Estimated R")+scale_fill_discrete(name = "Country", labels = EU) +
    labs(x= "Date",y="Estimated R")  +  #ylim(c(0.2,4.8)) + geom_line(aes(y = Mean.R.),color="black",size=0.1,alpha=0.8) +
      geom_vline(xintercept=as.Date("2020-06-24"),size=1)+
    geom_text(aes(x = as.Date("2020-06-24"),y=0.1,label="2020-06-24"),size=2,vjust=-1,hjust=1)+
    my_theme+theme(axis.title.x=element_blank(),legend.position="bottom")+
  scale_colour_brewer(type = "qual", palette = "Set1", direction = 1, aesthetics = "colour") + facet_wrap(facets=vars(Location),scales="free_y") + 
  geom_rect(mapping=aes(xmin=min(GerOutBreak1$data_to_plot$dates),xmax=min(GerOutBreak1$data_to_plot$dates),ymin=0,ymax=0,fill="Weekdays"),alpha=0.3)
```


The transmission curves show a significant increase in the districts of Gütersloh and Warendorf and even in the state of Westphalen in late June. An increase was also observed in Berlin and in Germany. On the other hand, these curves exhibit a non-significant increase in Eisenach, Leipzig and Weimar; this could be caused by a few "imported" cases. Three-day windows did not help to detect the outbreaks and showed more noise. Thus a surge in the epidemic curves accompanied by a significant increase in the transmission curves could be used as a signal to detect outbreaks; although we can also observe that "hindsight is always clear", and the real-time transmission curves are not as easy to evaluate. 

## Question C, G: Implications for reopening (outbreaks in Catalonia) with different $si$ and indicators {#CatOutbreaks}

```{r cat-dates}
catOutBreak_start<-as.Date("2020-04-01")
catOutBreak_end<-as.Date("2021-01-10"  )
```

On 04-July-2020 in the county of Segrià in Lerida, Catalonia, Spain, was quarantined ("cordon sanitaire"), following a surge in the number of cases[@CatJulio]; this comarca neighbours the Autonomous Community of Aragón, where an outbreak was taking place[@AragonJunio]. Using the [Official Catalonia Basic Health Areas dataset (IDESCAT, Salut, Generalitat de Catalunya)](https://analisi.transparenciacatalunya.cat/Salut/Registre-de-casos-de-COVID-19-realitzats-a-Catalun/xuwf-dxjd)[@Catalonia], $R_t$ have been obtained for several Basic Health Areas in Catalonia, using several $si$/$GT$ distributions and keeping preprocessing settings constant (centered SMA smoothing with a span of 4 days, backwards distribution of negative values, no modification of spurious peaks, no correction for undetected cases). Figure \@ref(fig:Cat-rebound) displays the incidences in different Basic Health Areas, with the dates of the end of the national State of Alarm and the start of the "cordon sanitaire", and figure \@ref(fig:CataloniaR) displays the transmission curves.  The date when the state of alarm ended (2020-June-21) and the day when new travel restrictions were issues have been marked. 

```{r Cat-rebound,fig.cap="\\label{fig:Cat-rebound}Epidemic curves of Catalonia",echo=FALSE,fig.height=7,fig.width=8}

CatPop<-read.csv2("Catalonia.csv")
 
CatOutbreak<-comparemodes( 
list(
    `Girona`=incidf_prepro(incidf=get_cols(cat_z,source=CAT_zc_str,country="GIRONA",province="* All *"),undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>catOutBreak_start,dates<catOutBreak_end),
    `Lleida`=incidf_prepro(incidf=get_cols(cat_z,source=CAT_zc_str,country="LLEIDA",province="* All *"),undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>catOutBreak_start,dates<catOutBreak_end),
    `Barcelona Ciutat`=incidf_prepro(incidf=get_cols(cat_z,source=CAT_zc_str,country="BARCELONA CIUTAT",province="* All *"),undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>catOutBreak_start,dates<catOutBreak_end),
    `Metropolità Sud`=incidf_prepro(incidf=get_cols(cat_z,source=CAT_zc_str,country="METROPOLITANA SUD",province="* All *"),undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>catOutBreak_start,dates<catOutBreak_end),
    `Metropolità Nord`=incidf_prepro(incidf=get_cols(cat_z,source=CAT_zc_str,country="METROPOLITANA NORD",province="* All *"),undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>catOutBreak_start,dates<catOutBreak_end),
    `Catalunya Central`=incidf_prepro(incidf=get_cols(cat_z,source=CAT_zc_str,country="CATALUNYA CENTRAL",province="* All *"),undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>catOutBreak_start,dates<catOutBreak_end),
    `Catalonia`=incidf_prepro(incidf=get_cols(cat_z,source=CAT_zc_str,country="* All *",province="* All *"),undetected = 0, smooth_method="SMA (centered)", smooth_value=4, ignore=15,warnings="",negatives=dbfs)$df %>% dplyr::filter(dates>catOutBreak_start,dates<catOutBreak_end)),
mode="Catalonia outbreak", window = c(7),TD="TD",with_inci=TRUE,distributions = c("Du","Nishiura","Zhao","Ali","Ganyani Tianjin","Ganyani Singapore"),with_rho7 = TRUE, with_n_cum=14,pop_data=CatPop, loc_column="Region",pop_column="Poblacio")

CatOutbreak$data_to_plot<-rbind(CatOutbreak$data_to_plot,(CatOutbreak$empiricalR %>%
                                  dplyr::mutate(date_start=dates,date_end=dates,`Mean.R.`=rho7, `Quantile.0.025.R.`=rho7,
                                `Quantile.0.975.R.`=rho7,Method="rho7",distr="rho7",Mode=""))[,colnames(CatOutbreak$data_to_plot)])

CatOutbreak$incidences$dates<-as.Date(CatOutbreak$incidences$dates)
CatOutbreak$incidences$Location<-CatOutbreak$incidences$Country

add_weekdays(ggplot(CatOutbreak$incidences[CatOutbreak$incidences$Incidences>0 & complete.cases(CatOutbreak$incidences),], aes(x = dates, y = Incidences, group = factor(Location))), mindate=min(CatOutbreak$incidences$dates),maxdate=max(CatOutbreak$incidences$dates)) +
  geom_line(aes(y = Incidences,color=Location),size=1.7,alpha=0.8) +
  geom_text(aes(x = as.Date("2020-06-21"),y=1000,label="2020-06-21"),text=element_text(size=14),vjust=-1,hjust=1)+
    geom_text(aes(x = as.Date("2020-07-04"),y=1000,label="2020-07-04"),text=element_text(size=14),vjust=+1,hjust=1)+
    ggtitle("Outbreak in Catalonia, Spain")+ 
    geom_vline(xintercept=as.Date("2020-06-21"),size=1)+
    geom_vline(xintercept=as.Date("2020-07-04"),size=1)+
    geom_text(aes(x = as.Date("2020-06-21"),y=1000,label="2020-06-21"),text=element_text(size=14),vjust=-1,hjust=1)+
    geom_text(aes(x = as.Date("2020-07-04"),y=1000,label="2020-07-04"),text=element_text(size=14),vjust=+1,hjust=1)+ 
      labs(x=element_blank(),y="Daily incidence") + my_theme +
  scale_y_continuous(trans='log10',limits=c(1,max(CatOutbreak$incidences$Incidences)))+ 
   guides(colour = guide_legend(override.aes = list(alpha = 1))) + scale_color_brewer(type="Qual",palette="Set1")
 
```

Although the initial outbreak of Coronavirus in March-April had a more pronounced in number of cases in regions with more population (Barcelona Metropolitan Area), the outbreak in the end of June/beginning of July affected the less populated Area of Lleida.  

```{r CataloniaR, fig.cap="\\label{fig:CataloniaR}Transmission curves of Catalonia",echo=FALSE,fig.height=15,fig.width=11,eval=TRUE}
CatOutbreak$data_to_plot<-CatOutbreak$data_to_plot %>% rename(Location=Country,dates=date_end) %>% mutate (dates=as.Date(dates))
  
add_weekdays(ggplot(CatOutbreak$data_to_plot[complete.cases(CatOutbreak$data_to_plot),], aes(x = dates, y = as.numeric(`Mean.R.`), group = as.factor(Method))),mindate=min(CatOutbreak$data_to_plot$dates),maxdate=max(CatOutbreak$data_to_plot$dates)) +
    geom_line(aes(y = Mean.R.,color=Method),size=0.6) +
    geom_ribbon(aes(ymin = `Quantile.0.025.R.`, ymax = `Quantile.0.975.R.`,color=Method),alpha=0.01) +
    geom_line(aes(y = `Quantile.0.025.R.`,color=Method,group=Method),size=0.4,linetype=2,alpha=0.4) +
    geom_line(aes(y = `Quantile.0.975.R.`,color=Method,group=Method),size=0.4,linetype=2,alpha=0.4) +
    #geom_line(aes(y = Mean.R.,color=Regions),size=1.3,alpha=0.8) +
    #geom_hline(yintercept=1, linetype="dashed",  color = "black", size=1.05) +
    #ggtitle("Estimated R")+scale_fill_discrete(name = "Country", labels = EU) +
    labs(x= "Date",y="Estimated R")  +  #ylim(c(0.2,4.8)) + geom_line(aes(y = Mean.R.),color="black",size=0.1,alpha=0.8) +
      geom_vline(xintercept=as.Date("2020-06-21"),size=1)+
    geom_vline(xintercept=as.Date("2020-07-04"),size=1)+
    geom_text(aes(x = as.Date("2020-06-21"),y=max(CatOutbreak$data_to_plot$Mean.R.*0.6),label="21-Jun"),text=element_text(size=14),vjust=-1,hjust=1)+
    geom_text(aes(x = as.Date("2020-07-04"),y=max(CatOutbreak$data_to_plot$Mean.R.*0.6),label="04-Jul"),text=element_text(size=14),vjust=+1,hjust=1)+
    my_theme_13+theme(axis.title.x=element_blank(),legend.position="bottom")+
  scale_colour_brewer(type = "qual", palette = "Set1", direction = 1, aesthetics = "colour") + facet_grid(rows=vars(Location),cols=vars(distr),scales="free_y") + scale_x_date(date_breaks = "4 month",date_labels = "%b") + 
  geom_rect(mapping=aes(xmin=min(CatOutbreak$data_to_plot$dates),xmax=min(CatOutbreak$data_to_plot$dates),ymin=0,ymax=0,fill="Weekdays"),alpha=0.3)
  
```

Two $R_t$ surges can be seen in the Lleida area: One around May, in which daily incidences rose from less than 10 cases/day to 40-50 cases/day, and one in July, in which daily incidences rose from around 10-20 cases day in mid June to 80-90 cases/day at the end of June. Therefore, the information provided by the $R_t$ needs to be complimented by the incidence information. This confusion can be solved by using the OI ratio, as seen in figure \@ref(fig:CataloniaOA). Overall infectivity at time $t$ is defined as the sum of all the previously infected individuals, multiplied by their infectivity at time $t$ (given by the $si$ distribution)[@Cori2013]. Overall infectivity has been calculated by using the single MCMC-obtained or manuscript-derived $si$ or $GT$ distributions (section \@ref(mm)); population data for the Catalonia Health Regions has been taken from the Catalonian Health Service ([Població de referència del Servei Català de la Salut per a l’any 2020 - Dades per ABS i UP assignada](https://catsalut.gencat.cat/web/.content/minisite/catsalut/proveidors_professionals/registres_catalegs/documents/poblacio-referencia.pdf)) (accessed 2020-10-26). Using different $si$ or $GT$ distributions barely influences the overall infectivity. Effective reproductive numbers proved to be earlier indicators compared to active cases prevalence indicators (OI ratio, cumulative incidences) (June, July, September). 

```{r CataloniaOA, fig.cap="\\label{fig:CataloniaOA}OI ratio and $CIR_{14}$ curves of Catalonia Health Regions. The influence of the $si$ or $GT$ on the Overall Infectivity is barely noticeable",echo=FALSE,fig.height=15,fig.width=11,eval=TRUE}
CatOutbreak$OA<-CatOutbreak$OA %>% dplyr::mutate(Indic="Ov. Infectivity ratio") 
CatOutbreak$OAc<-rbind(CatOutbreak$OA %>% dplyr::filter(complete.cases(CatOutbreak$OA$OA_ratio)) %>% mutate (OA_ratio=OA_ratio),
                        (CatOutbreak$n_cum %>% dplyr::filter(complete.cases(CatOutbreak$n_cum$Ind)) %>%
                           mutate(OA_ratio=Ind,Indic="14 cum inc ratio",`Overall.Infectivity`=NA) %>%
                           tidyr::crossing(distr=unique(CatOutbreak$OA$distr))) [,colnames(CatOutbreak$OA)])
 

CatOutbreak$OAc<-CatOutbreak$OAc %>% rename(Location=Country) %>% mutate (dates=as.Date(dates))
 
add_weekdays(ggplot(CatOutbreak$OAc[,], aes(x = dates, y = as.numeric(`OA_ratio`), group=Indic)),mindate=min(CatOutbreak$OAc$dates),maxdate=max(CatOutbreak$OAc$dates)) +
    geom_line(size=1.3,aes(colour=Indic)) + 
    #geom_line(aes(y = Mean.R.,color=Regions),size=1.3,alpha=0.8) +
    #ggtitle("Estimated R")+scale_fill_discrete(name = "Country", labels = EU) +
    labs(x= "Date",y="Value")  +  #ylim(c(0.2,4.8)) + geom_line(aes(y = Mean.R.),color="black",size=0.1,alpha=0.8) +
    my_theme_12+theme(strip.text.y = element_text(size=10),
                      axis.title.x=element_blank(),legend.position="bottom")+
  scale_colour_brewer(type = "qual", palette = "Set1", direction = 1, aesthetics = "colour") + facet_grid(rows=vars(Location),cols=vars(distr),scales="free_y") + scale_x_date(date_breaks = "4 month",date_labels = "%b") + 
  geom_rect(mapping=aes(xmin=min(CatOutbreak$OAc$dates),xmax=min(CatOutbreak$OAc$dates),ymin=0,ymax=0,fill="Weekdays"),alpha=0.3)
 
```

OA ratio can therefore provide an accurate picture of outbreaks. It mostly follows the pattern of daily incidences epidemic curves. But compared to daily incidences, it is less influenced by weekday bias, but it might be influenced by the $si$ or $GT$ distribution, albeit very slightly.  

**Author disclosures:** Bautista Balbás LA: Theoretical work, programming, questions analysis, manuscript writing. Gil Conesa, Rodríguez Caravaca, Bautista Balbás, B: Manuscript review.

# Bibliography

Note: Unless otherwise specified, all datasets have been used in their latest update available as of `r format(Sys.Date(), "%B %d, %Y")`.
